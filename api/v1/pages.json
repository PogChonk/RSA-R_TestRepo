{"entries":[{"title":"Categories","url":"/categories/","tags":[],"body":"All categories > View all authors Scripting Studio"},{"title":"Authors","url":"/authors/","tags":[],"body":"All authors > View all categories artblart The difference between nil and \"void\" Category: Scripting Date: 28 September 2021 Pog Chonk CFrame Constructors Category: Scripting Date: 28 January 2021 Pairs vs IPairs Category: Scripting Date: 20 February 2021 Understanding Scope Category: Scripting Date: 17 August 2021 Intro to threads Category: Scripting Date: 14 October 2021 steve15 Logical operators, and their short circuiting behavior Category: Scripting Date: 01 September 2021 TheePBHST Packages: What are they? Category: Studio Date: 05 October 2021 Thodor12 CharacterAdded Category: Scripting Date: 21 May 2021 Data Saving Category: Scripting Date: 26 May 2021 Properties not updating Category: Scripting Date: 11 June 2021 CollectionService, how to use it Category: Scripting Date: 23 June 2021 Studio Widgets Category: Studio Date: 13 August 2021 Task Library Category: Studio Date: 15 August 2021 Touched, how to use it and it's limitations Category: Scripting Date: 20 August 2021 FindFirstChild and WaitForChild Category: Scripting Date: 29 August 2021 Events vs polling Category: Scripting Date: 09 October 2021 Script types Category: Studio Date: 09 October 2021 Using StarterGui Category: Scripting Date: 09 October 2021 Service usages Category: Studio Date: 14 January 2022 > View all categories"},{"title":"Home","url":"/","tags":[],"body":"All posts > View all authors > View all categories C CFrame Constructors by Pog Chonk Category: Scripting Date: 28 January 2021 CharacterAdded by Thodor12 Category: Scripting Date: 21 May 2021 CollectionService, how to use it by Thodor12 Category: Scripting Date: 23 June 2021 D Data Saving by Thodor12 Category: Scripting Date: 26 May 2021 E Events vs polling by Thodor12 Category: Scripting Date: 09 October 2021 F FindFirstChild and WaitForChild by Thodor12 Category: Scripting Date: 29 August 2021 I Intro to threads by Pog Chonk Category: Scripting Date: 14 October 2021 L Logical operators, and their short circuiting behavior by steve15 Category: Scripting Date: 01 September 2021 P Pairs vs IPairs by Pog Chonk Category: Scripting Date: 20 February 2021 Properties not updating by Thodor12 Category: Scripting Date: 11 June 2021 Packages: What are they? by TheePBHST Category: Studio Date: 05 October 2021 S Studio Widgets by Thodor12 Category: Studio Date: 13 August 2021 Script types by Thodor12 Category: Studio Date: 09 October 2021 Service usages by Thodor12 Category: Studio Date: 14 January 2022 T Task Library by Thodor12 Category: Studio Date: 15 August 2021 Touched, how to use it and it's limitations by Thodor12 Category: Scripting Date: 20 August 2021 The difference between nil and \"void\" by artblart Category: Scripting Date: 28 September 2021 U Understanding Scope by Pog Chonk Category: Scripting Date: 17 August 2021 Using StarterGui by Thodor12 Category: Scripting Date: 09 October 2021 > View all authors > View all categories"},{"title":"Scripting","url":"/category/scripting/","tags":[],"body":""},{"title":"Studio","url":"/category/studio/","tags":[],"body":""},{"title":"","url":"/year/2021/","tags":[],"body":""},{"title":"","url":"/year/2021/month/10/","tags":[],"body":""},{"title":"","url":"/year/2021/month/09/","tags":[],"body":""},{"title":"","url":"/year/2021/month/08/","tags":[],"body":""},{"title":"","url":"/year/2021/month/06/","tags":[],"body":""},{"title":"","url":"/year/2021/month/05/","tags":[],"body":""},{"title":"","url":"/year/2021/month/02/","tags":[],"body":""},{"title":"","url":"/year/2021/month/01/","tags":[],"body":""},{"title":"","url":"/year/2022/","tags":[],"body":""},{"title":"","url":"/year/2022/month/01/","tags":[],"body":""},{"title":"CFrame Constructors","url":"/scripting/2021/01/28/cframe-constructors.html","tags":["Pog Chonk","Scripting"],"body":"There’s 2 main constructors for CFrame’s. CFrame.new() and CFrame.lookAt(), these serve similar but different purposes. They both have 2 arguments, except lookAt has 3 arguments. For CFrame.new() , the first argument being the Position (Vector3) of the CFrame. The second one being optional, which is the Position (Vector3) to have it’s LookVector face towards. If the second argument is not set, then default orientation is automatically assigned (0,0,0). For example: CFrame.new(Vector3.new(0,0,0), Vector3.new(0,10,0)) or CFrame.new(Vector3.new(0,0,0)). The difference is that the first one sets the position and where to look at. The second one just sets the position and gives default orientation. For CFrame.lookAt(), the first argument being the Position (Vector3) of the CFrame. The second one not being optional, which is the Position (Vector3) to have it’s LookVector look at. The third one is optional though, which is the UpVector (Vector3). By default it’s Vector3.new(0,1,0). For example: CFrame.lookAt(Vector3.new(1,1,1), Vector3.new(1,10,1)) works fine. If you remove the Vector3.new(1,10,1) it’ll warn you that you didn’t define a lookAt position and that you need to assign one. CFrames have 3 more properties than Vector3s. Those being LookVector, UpVector, and RightVector (labeled below). -Z -> Forward -> CFrame.new(0,0,-1) Z -> Backward -> CFrame.new(0,0,1) Y -> Up -> CFrame.new(0,1,0) -Y -> Down -> CFrame.new(0,-1,0) X -> Right -> CFrame.new(1,0,0) -X -> Left -> CFrame.new(-1,0,0) All of these are some Vector3's in the range [-1,1] LookVector -> Forward -LookVector -> Backward UpVector -> Up -UpVector -> Down RightVector -> Right -RightVector -> Left"},{"title":"Pairs vs IPairs","url":"/scripting/2021/02/20/pairs-vs-ipairs.html","tags":["Pog Chonk","Scripting"],"body":"pairs internally uses next (in Base Lua, in Luau they use a custom internal iterator). pairs works on array’s and dictionary’s since it doesn’t have a determined order. ipairs numerically indices the table (1, 2, 3, ..., n: where n is the length of the table), which is why it only works on tables with numeric indices (or array’s). ipairs STOPS on nil values. The iterator for pairs looks like.. (in Vanilla Lua, we don’t know about Luau because they haven’t released their internal iterator) function pairs(t) return next, t, nil --// `nil` is generally avoided since it increases the performance of the loop end The iterator for ipairs looks like.. function iter(a, i) i = i + 1 local v = a[i] if v ~= nil then return i, v end end function ipairs(a) return iter, a, 0 end Fun Fact: If you manually set the array-type indices, Lua will think of it as a dictionary instead when iterating with pairs. Still behaves like an array though. local array = { [1] = \"A\", [2] = \"B\" } print(#array) --> 2 for index, value in pairs(array) do print(index, value) end --[[ 2 B 1 A Instead of 1 A 2 B ]]--"},{"title":"CharacterAdded","url":"/scripting/2021/05/21/characteradded.html","tags":["Thodor12","Scripting"],"body":"Often people use local character = player.Character or player.CharacterAdded:Wait() in order to fetch the character if it exists or wait until it exists. This call however has some indirect consequences that you do not directly notice. Usage in StarterPlayerScripts: Problem: The problem with using this statement inside StarterPlayerScripts is that the player scripts run when a player joins and do not run again when characters respawn. This means that you only fetch the character once at the start, and the character variable will then always point to the first character and never updates on respawn. This will cause problems when you then attempt to edit something using that character variable (because that character no longer exists). Solution: Avoid defining the character globally. Make sure that you always fetch the character whenever you need it, this generally means putting it inside of events. Usage in StarterCharacterScripts: Problem: In this case the statement is entirely unnecessary since StarterCharacterScripts run as soon as the character loads in. Solution: Use script.Parent instead Usage in StarterGui Problem: Code running in StarterGui is the same as StarterCharacterScripts, the lifetime of a GUI is the same as a character (depending on whether or not ResetOnSpawn is true). This however doesn’t mean you should utilize this solution as scripts here still have the potential to run the same way like StarterPlayerScripts (when ResetOnSpawn is false). Solution: See usage in StarterPlayerScripts Usage in PlayerAdded Problem: When used inside PlayerAdded this code will only run for the first time the player spawns in. Solution: Use :Connect for your CharacterAdded event game.Players.PlayerAdded:Connect(function(player) player.CharacterAdded:Connect(function(character) end) end) Usage inside of event callbacks: Problem: When you use this statement inside of events (for example in remotes) you will cause that thread to hang for some time, this becomes an even greater problem if you game does not have CharacterAutoLoads enabled. Events are meant to be processed as soon as possible and then stop execution. Solution: Knowing that events should always stop execution as soon as possible it’s recommended to abort the event if the condition for an existing character is not met local character = player.Character if not character then return end This will abort the request as soon as it sees that there is no character, instead of waiting until there is a character present."},{"title":"Data Saving","url":"/scripting/2021/05/26/data-saving.html","tags":["Thodor12","Scripting"],"body":"Too often we see people that combine PlayerAdded/PlayerRemoving to make datastore saving scripts. In theory this looks fine but in practice it doesn’t save your data half of the time, why? When does the game exit? The game stops running under any of 3 conditions All players have left the game A server shutdown was requested from the game page A game wide server migration was issued (basically server shutdown and teleport) When inside of studio you’re always alone, thus if you leave the game, the server will immediately kill itself since the last player left. Asynchronous It’s important to remember that requests to the datastores are made asychronously, it takes time to complete them, they’re not done just immediately. Knowing that the game immediately exits after the last player has left and that a datastore request takes time to complete, it’s obvious that the server shuts down before the datastore request can finish, at this point is when dataloss occurs. How to fix it? Roblox provides a way that you can run code before the server immediately exits, game:BindToClose, you can bind any amount of functions to right before the game closes, these functions can run for at most 30 seconds before the server kills itself anyway. The way we use this is to save the data for all remaining players to make sure everything is saved before we exit the server. Example: function SaveData(player) -- implement your saving logic here end game.Players.PlayerRemoving:Connect(SaveData) game:BindToClose(function() for _, player in ipairs(game.Players:GetPlayers()) do SaveData(player) end end) I get a weird warning in the console saying “Datastore request was added to the queue”. This is because you’re making two simultaneous write requests, 1 issued by PlayerRemoving and the other one issued by BindToClose. You can safely ignore this warning because Roblox can only write to the same datastore key every 6 seconds anyway."},{"title":"Properties not updating","url":"/scripting/2021/06/11/properties-not-updating.html","tags":["Thodor12","Scripting"],"body":"Sometimes we see people that do things like setting the Text of a TextLabel recusively, wanting it to constantly update it’s value based on a leaderstats value or something similar, however the GUI doesn’t show a single update despite changing the value of the leaderstats. An example of this is like this: local value = game.Players.LocalPlayer.leaderstats.MyLeaderStat.Value while true do game.Players.LocalPlayer.PlayerGui.MyLeaderstatsGui.TextLabel.Text = value wait() end If you have code like this the text will never update because the variable called value will always contain the same value, the one it got when the script started running. Luckily there’s an easy way to solve this. It’s better when you keep the leaderstats value object itself in a variable and instead check the .Value everytime the loop runs, example: local myLeaderStatsObject = game.Players.LocalPlayer.leaderstats.MyLeaderStat while true do game.Players.LocalPlayer.PlayerGui.MyLeaderstatsGui.TextLabel.Text = myLeaderStatsObject.Value wait() end This will work just fine, however we can improve it one step further, generally it’s not even needed to put things like this in a while loop, it’s just wasted performance, you’re running this code even if there are no updates in the value, this can be solved if we use a Changed listener on the leaderstats values, example: local myLeaderStatsObject = game.Players.LocalPlayer.leaderstats.MyLeaderStat myLeaderStatsObject.Changed:Connect(function(value) game.Players.LocalPlayer.PlayerGui.MyLeaderstatsGui.TextLabel.Text = value end) This code will only run when a change in the value would be detected, greatly increasing the performance of the script. This example given the updating of Text is just one example, the exact same idea applies to other cases aswell."},{"title":"CollectionService, how to use it","url":"/scripting/2021/06/23/collectionservice.html","tags":["Thodor12","Scripting"],"body":"CollectionService is a really underrated service and not many people seem to know about it, on it’s own it honestly doesn’t even look that special but when used correctly this service can improve your game tenfold. Theoretically this service can be used in whatever scenario you desire as it’s versatility is amazing. What does it do? CollectionService does nothing more than manage tags. These tags are just basic strings that can be given to any instance in your game. Through CollectionService you can get, add, remove tags, aswell as getting all instances in the game that have a given tag. This allows you to lookup all instances in a game which contain a given tag and quickly get them back as a table in your script, this can be really helpful in scenarios where you don’t want to search through your whole game to find what you’re looking for. Examples I will give 3 short examples of what this can be used for Kill bricks Ah yes, we all know our classic kill bricks, you step on em, you die. Many people tend to just put a script in the part, bind a Touched listener to the part, and just copy the part along with the script over and over. However now you need to change your script, oops I have to update a hundred scripts, not ideal. CollectionService can help with this by giving all your kill bricks a certain tag, let’s say “KillBrick”, now you only need 1 script which gets all instances in the game with the given tag, iterate all of those parts and give them a Touched listener, 1 script, only 1 place to edit, all killbricks have their implementation. Getting all characters What if we want to quickly get all the characters, not just player characters but also NPC’s, again we can use CollectionService to give a tag to all of our humanoids in the game. For players we can do this using CharacterAdded and for our NPC’s we can give them a tag either in studio manually or whenever you create them. This allows you to later on in the code automatically find all humanoids that exist in the game with your tag, meaning you don’t need to even put all NPC’s together in a specific folder and use GetChildren() or something similar, you can just get the entire list in 1 go and be done with it. Day/Night lighting Proper lighting is nice in games, even better if your lights adapt to the day night cycle, this is similar to kill bricks, you can give all your lights in your game a tag, whenever the time of day changes you can simply fetch all lights in the game by using CollectionService, iterate all of them and enable or disable all lights in 1 go, only 1 script needed. Like this you can think of thousands of possible usecases for CollectionService, there’s no end to them. How do I start using it? Simple, all you have to do is include the service in your scripts using game:GetService(“CollectionService”) like you would do for any other service, you can find it’s documentation here. Now you might be wondering, how do I actually give these instances tags, well one way is through CollectionService in the command bar like so: for _, item in ipairs(game:GetService(\"Selection\"):Get()) do game:GetService(\"CollectionService\"):AddTag(item, \"YourTagName\") end This would automatically add the tag with YourTagName to all the instances you have selected in the explorer window. However this is not really ideal, it requires a lot of working, requires you to type out the code in the command bar all the time, etc. Luckily the community isn’t stupid and thanks to tiffany352 we have an amazing plugin called the Tag Editor. This plugin allows you to manage all the tags in your game and easily apply them to whatever instance you want."},{"title":"Studio Widgets","url":"/studio/2021/08/13/studio-widgets-not-showing.html","tags":["Thodor12","Studio"],"body":"Problems with Studio widgets not showing up? If you ever have an issue with certain widgets not being able to show up you can check the following things: Make sure you actually have the widget enabled. In the menu go to View tab and check if the required widget is enabled. Check if your widget isn’t already open but docked to the same position as another widget, you see tabs showing the individual widgets. Check that your widget is floating around, not docked to studio. Turn on your other monitors, sometimes you might have placed a floating widget on another monitor, in that case the widget will remain in that position despite the monitor being turned off, making it invisible. In case you cannot get the widget to show at all, your last resort is to reset the studio widget layout. You can do this through CTRL + P (Cmd + P on Mac), and then typing in >Reset View, this will reset all the widgets in studio to their default positions."},{"title":"Task Library","url":"/studio/2021/08/15/task-library.html","tags":["Thodor12","Studio"],"body":"Along with the update of the Task Library (see also task library documentation), we got a new set of functions for task scheduling, along with a new and improved wait() function, namely task.wait(). This function is the new equivalent of doing RunService.Heartbeat:Wait() which was always considered a better option. Along with the new Find and Replace window Roblox recently introduced it’s now very easy to convert to this new function by use of a regex operation: Fill in in the find bar: (?<![\\S\\.])wait\\( Enable regex searching (third icon next to find bar, the dot with the star) Fill in the replace bar: task.wait( What this does it looks for all occurences of wait( with a couple of additional checks It does not catch cases that are preceded by any other non whitespace character (means it won’t alter things like variables or functions which are trailing with wait( It does not catch cases that are preceded by a dot (this means it won’t accidently overwrite any occurences of existing task.wait( Note: This same method works for all task library functions, for example if you wanted to change the occurences of spawn you would do: (?<![\\S\\.])spawn\\( and task.spawn(."},{"title":"Understanding Scope","url":"/scripting/2021/08/17/understanding-scope.html","tags":["Pog Chonk","Scripting"],"body":"A scope is a section of code where a variable is defined, in a valid state, and the variable is visible. e.x. do local x = \"banana\" --| X was declared in this scope, cannot be accessed in outer scopes, but can be accessed in inner scopes. print(x) --> banana end print(x) --> nil Global VS Local Variables A local variable has the lifetime of the scope they’re declared in and are locked to that scope and inner scopes. A global variables lifetime is the time the script is running; it is not locked to any scope. e.x. do local x = \"banana\" -- Local Variable -- X's lifetime is dependent on this scope since it's declared here. y = \"apple\" -- Global Variable -- Y's lifetime is only dependent on the runtime of the script. end print(x) --> nil print(y) --> apple This applies with functions too, functions declared via local function foo() is almost like doing local foo = function() end. e.x. local function foo() -- function foo() -- end -- end -- Similar too local foo foo = function() -- foo = function() -- end -- end Nesting Scopes do local x = \"banana\" y = \"apple\" do local z = \"tomato\" t = \"pear\" print(x, y, z, t) --> banana apple tomato pear end print(x, y, z, t) --> banana apple nil pear end print(x, y, z, t) --> nil apple nil pear Shadowing Shadowing a variable is when you redefine what the value is later down in the same scope or an inner scope and results in unwanted behavior. A reason why globals should be avoided. e.x. You have a variable x and you define another one in a different scope y, but you named it x instead. local x = \"banana\" do local x = \"apple\" print(x, y) --> apple (expected banana) nil (expected apple - shadowed outer variable `x`) end print(x) --> banana"},{"title":"Touched, how to use it and it's limitations","url":"/scripting/2021/08/20/touched-how-to-use-it.html","tags":["Thodor12","Scripting"],"body":"Touched is an event which you can use to detect whenever a part gets touched by a different part, however people often claim this is too inaccurate and that’s for a good reason. Usage Like said before, Touched is an event, which means you have to use :Connect in order to use it, here’s an example: local part = script.Parent part.Touched:Connect(function(otherPart) print(part .. \" got touched by \" .. otherPart) end) Now this isn’t very difficult and very simple to use, however it’s more important on what parts you set your Touched listeners on, we’ll go deeper into this at the limitations. Sometimes parts don’t always trigger the Touched event, take for example a part you are supposed to jump on top of, it’s important to to know that if you want Touched to fire more reliably you have to make bigger parts surrounding the actual part, hitbox parts. You do this to give Touched some more breathing room to be able to fire properly. Limitations As said before Touched isn’t perfect, but that’s most of the time due to improper usage or absurd expectations from the developer side. A Touched event has to rely on two or more instances intersecting during the physics calculation step of the current frame. That condition doesn’t seem too difficult to hit, however take into consideration that for you, the end user, everything in the game looks smooth, however for the engine itself that’s not the case. When the engine calculates the intersections it just takes the current known position of the part, it doesn’t check every viable position since the last known position in the previous frame and attempts to find intersection points. This means that if parts move too fast an intersection can be missed, see the image below. For clarification the gray parts are parts with Touched listeners. The black lines are trajectories of parts moving around in the workspace. The red lines are when a physics step occurs, the places where an intersection is calculated. Now what really goes on in this image, the black line is basically what we see, we assume by looking at the black line that we get an intersection. However in truth this doesn’t happen, as we explained before intersections are calculated during the physics steps (the red lines). The engine doesn’t take into consideration where it previously came from or the part it travelled, it only knows the current point it’s at. Therefore it’s possible that at the time the physics step takes place, there’s no ongoing intersection between two parts. This can be caused by 3 common issues: Too small parts Too high velocity No big enough intersection area In case of the first one the parts are not big enough in order to get an intersection, this goes hand in hand with the second one, velocity. When parts move too fast the distance between the red lines becomes longer, meaning there’s more potential for intersections to get skipped. The last one applies to the left side of the image, when there’s practically no intersection area (surface touch), it gives Touched almost no capability to fire. How to fix these issues We’ve already named the fixes in the previous section. You have to make sure your parts are big enough and don’t travel too fast so they have a chance to intersect with other parts. Additionally you can also make sure the parts have to be Touched are bigger, that way you can improve your chances too."},{"title":"FindFirstChild and WaitForChild","url":"/scripting/2021/08/29/findfirstchild.html","tags":["Thodor12","Scripting"],"body":"There’s some pretty big differences between FindFirstChild and WaitForChild which you have to understand in order to properly use them. FindFirstChild When using FindFirstChild you are not guaranteed to actually get a result, this is because it attempts to find the first child with the given name. If this child does not exist it returns nil. Note that this method also doesn’t wait for a child to appear. If the child isn’t present at the time FindFirstChild runs it’s either just not present at all, or if you assume it has to be present it could be it’s not replicated from the server yet. This means that constructions where you directly access the result of FindFirstChild like: print(parent:FindFirstChild(\"Child\").Name) are not guaranteed to work and can potentially run into errors at runtime. You need to make sure that you properly check if the result is not nil before using the result: local child = parent:FindFirstChild(\"Child\") if child ~= nil then print(child.Name) end WaitForChild Unlike FindFirstChild, WaitForChild is guaranteed to always return an instance, however it yields the current thread until a child with the given name is present. WaitForChild also allows you to pass a number as the second argument which defines the timeout. This means WaitForChild will only wait for an x amount of seconds. If you use this parameter then WaitForChild can return nil too, just like FindFirstChild. Additionaly WaitForChild also drops warnings in the output: “Infinite yield possible …”, this means WaitForChild has already been yielding for 5 seconds already without being able to get a result already. Most of the time this means that the instance you were expecting to load doesn’t actually exist. In some rare cases it’s actually possible that it would take more than 5 seconds to load. Note that this warning is not thrown when you provide the timeout parameter."},{"title":"Logical operators, and their short circuiting behavior","url":"/scripting/2021/09/01/logical-operators-short-circuiting.html","tags":["steve15","Scripting"],"body":"A key part into learning how to use pseudo ternaries in Lua(u) is understanding how each part of it works, and this was written especially for that. But, before we get into the workings of logical operators and their short circuiting behavior, the truthyness and falsyness of values needs to be covered first. What does it mean for something to be truthy or falsy? Since the truthyness and falsyness of values in Lua(u) should be understood before diving into the world of logical operators, the following is a brief overview: Falsy For something to be considered falsy, it has to evaluate to nil or false. If you’re not sure of what nil is, it’s a data type that represents nothing. The only examples of falsy values are nil and false. Truthy For something to be considered truthy, it must not be falsy. Examples of truthy values are numbers, strings, tables, and anything else that’s not falsy. Do keep in mind that the truthyness and falsyness of values vary depending on the programming language you’re working with. That is, a value considered truthy in one programming language may be falsy in another and vice versa. What are the logical operators? Usually, an operator has at least one value it operates on, which are its operands. For example, in the expression 1 + 14, 1 and 14 are the operands. And if you aren’t already aware, there’s three logical operators you can work with: or The logical or operator operates on two operands. or only wants one of its operands to be truthy. If the is truthy, then it’s evaluated and returned, without evaluating the . However, if the is falsy, then the is evaluated and returned. Here’s some examples: -- 15 is . -- 16 is . print(15 or 16) -- Prints 15 because 15 is truthy. -- false is . -- 15 is . print(false or 15) -- Prints 15 because false is falsy. -- CHALLENGE #1: -- Can you figure out what this would print? print(false or (16 or 15)) and Likewise to or, the logical and operator operates on two operands as well. The difference being that and wants both of its operands to be truthy. If the is truthy, then the is evaluated and returned. However, if the is falsy, then it’s evaluated and returned, without evaluating the . Here’s another set of examples: -- 14 is . -- 15 is . print(14 and 15) -- Prints 15 because 14 and 15 are truthy. -- nil is . -- 16 is . print(nil and 16) -- Prints nil because nil is falsy. -- CHALLENGE #2: -- Can you figure out what this would print? print((\"Cool.\" and \"Epic.\") and \"You’re cool and epic!\") not Unlike the others, the logical not operator only operates a single . Being the simplest of them all, all not does is invert its . If the is truthy, then not returns false. However, if the is falsy, then not returns true. Here’s the last set of examples: -- 15 is . print(not 15) -- Prints false because 15 is truthy. -- nil is . print(not nil) -- Prints true because nil is falsy. -- CHALLENGE #3: -- Can you figure out what this would print? print(not (not (false and 15))) Example usage of NOT Let’s say you have a guiObject which you want to toggle its Visible property’s value on and off each time a guiButton is clicked. A naive solution would be: guiButton.MouseButton1Click:Connect(function() if guiObject.Visible then guiObject.Visible = false else guiObject.Visible = true end end) An alternative and more concise solution, however, would be: guiButton.MouseButton1Click:Connect(function() guiObject.Visible = not guiObject.Visible end) The example above would work because let’s say that the guiObject.Visible property’s value starts off as true, meaning it’s visible. If you click the guiButton, not would invert true and the result would be false because true is truthy. Then, the guiObject.Visible property’s value is set to false, meaning it’s invisible. If you click the guiButton again, not would invert false and the result would be true because false is falsy. -- guiObject.Visible’s value starts off true. -- FIRST CLICK: guiObject.Visible = not guiObject.Visible -- Which becomes: guiObject.Visible = not true -- Which becomes: guiObject.Visible = false -- SECOND CLICK: guiObject.Visible = not guiObject.Visible -- Which becomes: guiObject.Visible = not false -- Which becomes: guiObject.Visible = true So as you click the guiButton, this pattern repeats. Short circuiting with logical operators As mentioned earlier, when the of or is truthy, it’s evaluated and returned, without evaluating the . And it was also mentioned, when the of and is falsy, it’s evaluated and returned, without evaluating the . This idea of or and and only evaluating what it needs depending on the truthyness or falsyness of its operands is called short circuit evaluation or short circuiting, for short. An important thing to keep in mind is that although this section focuses on short circuiting with the logical operators, short circuiting isn’t just limited to them. That is, if-elseif statements can also short circuit their conditions. Pseudo Ternary IMPORTANT UPDATE: Roblox now officially supports ternary like operations, see here Some programming languages provide direct support for something called the ternary ? operator, or ternary, for short. However, Lua(u) doesn’t. Nonetheless, you can think of the ternary as a shorthand, for using if-else statements, that operates on three operands. Here’s its general syntax: -- ? : -- Where: -- is the condition being tested. -- is the expression that’s evaluated -- and returned if the condition is truthy. -- is the expression that’s evaluated -- and returned if the condition is falsy. So its syntax can also be expressed as: -- ? : Now, as mentioned before, Lua(u) doesn’t provide direct support for the ternary. However, by using the logical and and or operators and their short circuiting behavior, together, it’s possible to get behavior similar to the ternary. Pseudo just means fake. So, this is why it’s called the pseudo ternary operator or pseudo ternary, for short. Here’s what its syntax looks like: -- and or -- Or if you prefer: -- and or As you can see, the pseudo ternary syntax is not far from the actual ternary syntax. So, once again, here’s the way it works: If the or is truthy, then the or is evaluated and returned as the first operand of or. Since the or is expected to be truthy, it’s evaluated and returned. However, if the or is falsy, then it’s also evaluated and returned as the first operand of or. But here’s where things change. Since the first operand of or is falsy, the or is evaluated and returned. Here’s some examples: local x = 15 -- x == 15 is or . -- “15 is a cool number.” is or . -- “But this number is cooler” is or . -- Prints “15 is a cool number.” if x == 15. print(x == 15 and \"15 is a cool number.\" or \"But this number is cooler.\") -- CHALLENGE #4: -- Can you figure out what this would print if part.Anchored == true? print(part.Anchored and \"Anchored\" or \"Unanchored\") Caveats Why pseudo ternaries won’t always work Unfortunately, pseudo ternaries will never work the exact same way as the actual ternary is because when the or is falsy, the or is evaluated and returned which is because of how or works. For this reason, it’s recommended that when you have a falsy expression in the place of the or that you use if statements instead. As an alternative solution, you can use not to invert the or so that it’s a truthy expression, as it’s expected to be. However, doing that would only add the complexity of the issue. Therefore, the first solution is better. Pseudo ternaries vs if statements A lot of the time if statements can be replaced by pseudo ternaries, however, this doesn’t mean that you should always do this. Overusing pseudo ternaries for the sake of reducing the amount of if statements (and for this reason, the amount of lines) is a bad practice to follow. Use pseudo ternaries in places where it would improve the readability of your code to you, your future self and other programmers as well. Because at the end of the day, your code its readability should generally be prioritized over its size."},{"title":"The difference between nil and \"void\"","url":"/scripting/2021/09/28/diff-nil-void.html","tags":["artblart","Scripting"],"body":"A common misconception in Lua is that functions have an implicit return value. This is not true. Functions have an implicit return instruction, meaning a function will always return after execution even if no return is specified. This implicit return instruction will never carry any value. This is not to be confused with nil, however. For the sake of explanation, we will call this complete absence of value void. The source code for Lua 5.1 refers to it as None but void is a much more common term in the world of programming. The difference between the two comes from the way emptiness is represented in Lua. nil is a value that represents the absence of a value. It is possible to work with nil in Lua because it is a native datatype. For the sake of the analogy we will call nil a “tangible nothing.” It is a value that we can use that represents nothing. void on the other hand, is an “intangible nothing.” Lua does not comprehend this lack of value because it was designed to use nil as a lack of value. The only way to detect this nothingness is through C functions. Take this for example: local function returnsVoid() -- nothing here! return instruction is auto generated. end local function returnsNil() return nil end print(select(\"#\", returnsVoid())) --> 0 print(select(\"#\", returnsNil())) --> 1 select is a function with some overloads, the one we’re using simply counts the number of arguments passed to it and returns it. As we can see, there is a detectable difference. However, in most cases this void will end up being coerced into nil because it makes more sense to the user. This begs the question, “If void is coerced into nil most of the time, why does it matter?” This is the beautiful part. For the most part, it really doesn’t matter! There is a few cases where it can come back to bite you though. Let’s reuse the functions we defined earlier for this next example. local t = {1,2,3} table.insert(t, returnsNil()) --> while generally useless, this code is safe and causes no issues. table.insert(t, returnsVoid()) --> this will error during runtime because table.insert is an overloaded function! -- it expects 2 or 3 arguments but since void is a complete absence of value, it only sees table.insert(t) A Roblox related example of this difference is in the function Instance:GetAttribute(). It has the capability to return void which comes with the same problems as the above example."},{"title":"Packages: What are they?","url":"/studio/2021/10/05/packages-in-roblox.html","tags":["TheePBHST","Studio"],"body":"As your game continues to develop and get larger in assets, you may start to realize (or not) that you have the same scripts in different assets in your game, and once you begin to lose track of these assets keeping track of them will get very difficult soon. So, how could you solve this problem? Well thankfully, Roblox has introduced us a feature called, Packages. And no, these aren’t the packages that make you look nice and strong, but these are the packages that allow you to make commits to your scripts (or even physical objects) and be able to publish to other places, update other packages, and view the changes to these packages. In this post, I’ll be showing you how to use packages, why should you use them, and other cases for them. disclaimer: this post was referenced off of the Roblox Packages – Reusable Game Assets article provided by the Roblox Developer Resources site. Setting Up Your Workspace Open up a new empty Baseplate. (optional: set ClockTime to 0) Create three new Parts Name your either of your three parts to Red, Green, and Blue. (optional: space them out at least 10 studs) Change the colors of the parts to either Really red, Lime green, or Really blue. Insert a SurfaceLight into each part and apply these changes to its properties. Angle: 10 Brightness: 20 Range: 6 Create a Script inside of the Red part. Editing the Example Script So in this new script we’ve created in the Red part, we’re going to add a simple piece code. local Part = script.Parent local Light = Part.SurfaceLight Part.Color = Light.Color simple, right? Go ahead and press Run (or F8) and check that the code works, if not, check the instructions below. Then copy the script and paste it into the other two parts, Green and Blue. Press Run again to ensure all the SurfaceLights match up with the part’s color. Then, in the Red part, open the script again and add these changes. local Part = script.Parent local Light = Part.SurfaceLight Part.Color = Light.Color Part.Material = Enum.Material.Neon Part.Size = Vector3.new(5, 5, 5) Just like before, press Run and ensure the code works and after that copy the modified script and overwrite the previous scripts inside of the other two parts. Creating a Package Now that we’ve gotten the easy part out of way, you may begin to see how tedious this process could be, manually updating every script and keeping track of them. That’s why packages will come in handy when these type of situations happen as you develop your game. So let’s create our first package! (keep in mind that packages save into your inventory) Right-click the script located in the Red part. (or either of the three, just know that it’ll be the script you’ll create changes inside of) Click Convert to Package... from the menu. As you do that, a dialog window will appear. Fill out the Title to Test Package or anything you’d like. Press Submit. Once you’ve submitted, you should see something called PackageLink inside the script. That’s a way to know you’ve successfully created your own package! Accessing Your Packages and Inserting Them There are two places where you can access your packages, Toolbox or the Packages folder located in Asset Manager. Now for our convienience, we’ll be accessing our packages via Asset Manager. If you don’t know where it is, right-click on the ribbon (if not there, Ctrl + F1), and click on Asset Manager. Access the new package inside of the Packages folder and you should be able to see the package that you just created. From here, delete the scripts located in the other two parts which do not have a PackageLink inside of them, and then insert the package into each part. Committing Changes to Packages It doesn’t matter which package you edit from as long as it’s the same as the others. Now that we have multiple packages, let’s figure out how to commit changes to all of the packages in the game. (you can also update packages in other games as long they’re the same and the permissions are met) First, let’s add some revisions to our code. Open the package and edit the code to this. local Part = script.Parent local Light = Part.SurfaceLight Part.Color = Light.Color Part.Material = Enum.Material.Neon Part.Size = Vector3.new(5, 5, 5) Part.Transparency = 0.8 Light.Brightness = 40 As you edit the code, you’ll start to see an orange dot on the left of the package’s name in the Toolbox. This indicates that there has been a change made to the code and it’s most likely different from the current published version of the package. Exit out of the script tab and let’s start commiting these changes. Right-click the edited package. Click Publish Changes to Package. A prompt will appear noticing you about the change you are about to publish. If you don’t want to see this dialog everytime you publish a change to a package, tick the box. (not recommended) Press Publish when you are ready. Congratulations, you’ve successfully published your first package. Updating Packages Once you’ve updated a package, you want to also update the other packages now that they are considered outdated . There are two methods to updating your packages. Method 1 being updating all of them at once and Method 2 is updating the other packages one at a time. Method One Right-click a package that has been updated to the latest version. Click Update All. You will see a dialog appear. There are four things to discuss here. (Version, Published On, Places, and Submit/Cancel) Version: Shows the current version number. Published On: Shows when the current version was last published. Places: These are the places that have the current package inside the game. You have the option to publish these packages in those games. Submit/Cancel: Self-explanatory. Submit the update. Method Two Locate the outdated package you’d like to update. Right-click the package. Click Get Latest Package. A prompt will appear. (read the notice in Committing Changes to Packages) Click Get Latest. You’ve successfully updated your packages. Congrats! Viewing the Changes on a Package Let’s say somebody in your team, or you wanted to know what changes were made to the package. Well you can see what changes you’ve made with a few simple steps. Right-click the unpublished package or outdated package. (you’ll know if a package is unpublished by the orange dot / sync indicator) Click View Script Changes.... That was pretty simple, but what are we looking at? - Anything highlighted in red means that it was taken out or modified. - Anything highlighted in green means it was added in or modified. Conclusion Well it’s been a long read but that covers the basics of packages. There’s not much left other than reverting changes to a package(s). Let’s cover what you were able to do. Create a package. Update a package and the methods to do so. View changes in a package. If you have any questions regarding packages, don’t be afraid to ask in the Discord. Thank you for reading and have fun programming!"},{"title":"Events vs polling","url":"/scripting/2021/10/09/events-vs-polling.html","tags":["Thodor12","Scripting"],"body":"Roblox is an event-driven system, but what does this entail exactly? Event-driven vs polling What does this mean exactly? Event-driven is when you rely on events to trigger certain pieces of code, for example callback functions. Polling is where you use continuous checks to see if a certain condition is met and then taking action. Just from reading that it shouldn’t be hard to guess that event-driven solutions are better because it simply won’t require continuous checks. However do note in some cases a polling system is necessary whether you like it or not. But how do I use events? Say you need to update your text on a GUI based on a leaderstats value. A polling example would look something like this: local value = game:GetService(\"Players\").LocalPlayer.leaderstats.MyValue while true do script.Parent.Text = value.Value task.wait() end Although this works this has a big flaw, unnecessary updates. Most of the time your value likely isn’t even updating, so you are continuously setting the Text of your TextLabel even though there’s no change at all, this is a waste of performance. An event driven system can fix it by doing this: local value = game:GetService(\"Players\").LocalPlayer.leaderstats.MyValue value.Changed:Connect(function() script.Parent.Text = value.Value end) This will only update the Text of the TextLabel whenever a change occurs in the value object. Roblox has events for this (they are called RBXScriptSignals) and they have a :Connect method, :Connect takes a single argument, a callback function. This function is fired by the Roblox engine whenever the event is fired either internally or by other means. Events come in all sorts of forms, be it changed listeners on instances, events like PlayerAdded/CharacterAdded or even manually callable events like Remote/Bindable events. Like I said before it’s not always sunshine, there are cases where you most definitely need to do something continuously. This comes mostly into play when working with physics, for example movement. Roblox has a limit when it comes to changed events, they are only triggered on direct property assignments, but physics updates do not trigger changed events. This means that if you need to check for changes in the MoveDirection of the Humanoid you will find yourself needing a polling solution to constantly read out the MoveDirection property, you can do this either by using while loops, or preferably by using RunService. For example: -- Localscript inside of the character local humanoid = script.Parent.Humanoid humanoid:GetPropertyChangedSignal(\"MoveDirection\"):Connect(function() -- this will never fire because it's updated through physics end) game:GetService(\"RunService\").RenderStepped:Connect(function(step) print(humanoid.MoveDirection) end) Even though you must do something like this, it doesn’t mean you can build an event-driven system on top of this if you really want to. A changed event for example only has to check if the previous value doesn’t match the current value, and then trigger a function. For example: -- Localscript inside of the character local humanoid = script.Parent.Humanoid local lastDirection = humanoid.MoveDirection function moveDirectionUpdated() print(\"Move direction updated\") end game:GetService(\"RunService\").RenderStepped:Connect(function(step) if lastDirection ~= humanoid.MoveDirection then moveDirectionUpdated() end lastDirection = humanoid.MoveDirection end) Even though this is backed by a polling system you can still filter out the bulk of the work that needs to be done only when it’s necessary."},{"title":"Script types","url":"/studio/2021/10/09/script-types.html","tags":["Thodor12","Studio"],"body":"Roblox has multiple different script types, understanding the differences and where you can use them is essential for developing your games. All script types Roblox has three main script types that you need to know: Script The first one is the simple Script, also sometimes referred to as ServerScript or NormalScript. These scripts run on the server, indepently of all clients. They start running as soon a server is started. Scripts can run in the following places: Workspace Players (inside a specific player, for example the backpack) ServerScriptService LocalScript A LocalScript is the opposite of your regular Script, this one runs on the client (per player) as opposed to the server. These scripts are able to access game:GetService(\"Players\").LocalPlayer to know which client (player) the script is running for. LocalScripts can run in the following places: Workspace (as a child of the player it’s character) Players (inside a specific player, for example the backpack) ReplicatedFirst LocalScripts also have two services that they are unable to read/access: ServerScriptService ServerStorage Both of these services are not replicated to the client and thus the client can’t see anything in these services. ModuleScript ModuleScripts are a special case, these scripts cannot run on their own and have to be required by either a Script or a LocalScript in order to run. It doesn’t matter where you save these scripts but the general consensus is to put them either inside ServerStorage or ReplicatedStorage, the only thing that matters is that the script which is supposed to require the module can actually access it (for example LocalScripts cannot require modules inside ServerStorage, as they cannot see this service). As discussed before both script types also have some restrictions on what they are able to do (for example LocalPlayer). ModuleScripts inherit these restrictions based on what type of script they are required by, we’ll delve deeper into this in the next section. CoreScript Although these scripts cannot be created and are managed by Roblox, it’s good to know that they exist because they also come with their own permission level and have a more broad API which a lot of them normal scripts cannot access, for example CreateLocalPlayer. Permission levels Each script type comes with a different set of permissions, this is how the API distinquishes which script is able to use certain services or methods. For example only Scripts have access to DataStoreService and HttpService, whereas only LocalScripts can use UserInputService and ContextActionService. These permission levels can for the most part be found on the API documentation, where sometimes it says “xxxSecurity”. For example on the previously shown CreateLocalPlayer page you can see on the top it says “LocalUserSecurity”. This means it can only be called by the core or the command bar. Not inside (Local)Scripts nor plugins. You can find in-depth information about all permission levels here. Additionally you can find the entire API dump here so you can quickly see the security read & write permissions that are needed for the entire API here."},{"title":"Using StarterGui","url":"/scripting/2021/10/09/startergui.html","tags":["Thodor12","Scripting"],"body":"StarterGui is a service which lets you clone GUI’s to any player their PlayerGui folders, however you should avoid using it in code directly. How does StarterGui work? StarterGui itself doesn’t actually contain the GUI’s that the player gets to see. StarterGui is purely a container which is there to clone all it’s contents to the Player their PlayerGui everytime they spawn in. These GUI’s are essentially templates and nothing more. Why should I not use them in my code? Sometimes people want to manipulate something on their GUI, but they don’t see the changes appearing, why? Most of the time this is due to people manipulating the GUI inside StarterGui, as said before these are only templates. The changes are not being made to your actual current GUI but to the template, this means you’ll only see the changes if you die and respawn. If that happens the GUI gets cloned again from StarterGui back to your PlayerGui, at which point you’ll see the changes. The solution It’s actually really easy, we discussed before that StarterGui gets cloned to PlayerGui, so when you want to manipulate the GUI you have to find the current GUI inside your own player it’s PlayerGui. For example you can replace: local myGui = game:GetService(\"StarterGui\").MyGui with: local myGui = game:GetService(\"Players\").LocalPlayer.PlayerGui.MyGui There’s also an alternative, this is to simply keep the scripts that manipulate the GUI inside of your actual GUI instance. This way you can just refer to the GUI and any descendants of the GUI by using script.Parent, which is relative to your script. Localscripts only run when they are a descendant of the player, not if they are inside StarterGui. Which means it doesn’t attempt to mess with your GUI’s inside StarterGui."},{"title":"Intro to threads","url":"/scripting/2021/10/14/intro-to-threads.html","tags":["Pog Chonk","Scripting"],"body":"There’s a lot of misconceptions about threads in Lua(u). This article will explain the major parts that you need to know about threads. Let’s start off by what is a thread? You can think of a thread as a piece of paper and on this paper is instructions. These instructions are the code you wrote which then the employee will execute these instructions. The employee in our case is our VM (Virtual Machine). How do threads work? In Lua, threads are ran concurrently not in parallel. This is the biggest misconception. Well, what’s the difference? Concurrent Execution: Execution of a thread at a single time while being able to switch thread execution. Parallel Execution: Execution of two or more threads at a single time. Lua being Lua, it is single-threaded, running 1 thread at a time. Though, it seems as if it is running multiple threads at a time because of how fast its execution is. This is all done by internal magic. The internal magic relies on a “queue” of threads. The first thread gets thread execution and executes until it yields, when it yields it pauses thread execution for that thread and throws it in the back of the line. Then the next thread comes up and starts executing. This process is repeated until all threads have finished executing, or pretty much when all threads have “died”. In this example you can see that Thread #1 was executing, it yielded, then passed execution over to Thread #2, it yielded or finished executing (died), and then passed execution back over to Thread #1 to finish executing. Fun Fact: Roblox has implemented a beta stage of their multithreaded attempts using the Actor Model. How do you make and run a thread? In Luau, there are multiple ways of creating and running threads. In our case, we’re going to focus on coroutines. Coroutines are the most common ways of creating a thread. Simply by: coroutine.create(function() print(\"Hello World!\") end) Now, this only created the thread; it hasn’t executed the thread yet. To do this, we can use task.spawn or coroutine.resume. local thread = coroutine.create(function() print(\"Hello World!\") end) coroutine.resume(thread) --> Hello World! -- OR task.spawn(thread) --> Hello World! Tip: With task.spawn, you don’t need a thread, you can pass a function as well. task.spawn(function() print(\"Hello World\") --> Hello World! end) The difference here is that coroutine.resume is native to Vanilla Lua and that task.spawn communicates directly with the task scheduler and runs at 60hz. There is a second method using coroutines, coroutine.wrap, the only thing with this function is that it propagates errors to the output coming from the calling thread which terminates the calling thread instead of the created thread. E.x. coroutine.wrap(function() print(\"Hello World!\") --> Hello World! end)() You might be asking why are there two parentheses () at the end? Well, coroutine.wrap returns a function, more specifically a closure of the created thread which can be called to resume the thread. Which you can then do.. local closure = coroutine.wrap(function() while true do print(\"Hello World!\") coroutine.yield() end end) closure() --> Hello World! closure() --> Hello World! closure() --> Hello World! Now, you might be asking “what is coroutine.yield() and why is it there?” Well, the function name itself is self-explanatory. It will just yield the thread it was called in. This means that our thread is now suspended not dead. We do this because you cannot resume a dead thread. Once a thread is dead, it cannot be “revived” or resumed. Suspended threads, however, can by either calling the closure from coroutine.wrap or calling coroutine.resume passing in your thread. When a yielded thread becomes resumed, either by Roblox or manually, it will resume where it was yielded. So in our case: local thread = coroutine.create(function() while true do print(\"Hello World!\") coroutine.yield() --// When thread is resumed, the thread execution will start here from where it was yielded. end end) coroutine.resume(thread) --> Hello World! coroutine.resume(thread) --> Hello World! coroutine.resume(thread) --> Hello World! Why multiple threads in one script? Threads are useful for when you want blocking code to execute differently from the rest of your code. An example could be an infite while true do loop that constantly checks for a condition while the rest of your executes normally, not being blocked. E.x. local a = 0 local blockingCode = coroutine.create(function() while true do if a > 10 then print(\"Not there yet\") else print(\"We're here!\") end a += 1 task.wait() -- task library's supersede of wait() end end) task.spawn(blockingCode) --... // Rest of this code runs, while the \"blockingCode\" thread is yielding. -- The \"blockingCode\" thread will resume execution whenever the main thread finishes its execution."},{"title":"Service usages","url":"/studio/2022/01/14/service-usages.html","tags":["Thodor12","Studio"],"body":"The explorer in Roblox Studio contains a lot of “top level services”, all of those services have a specific function and are sometimes not used correctly. I’m going over all these services and define what they are supposed to be used for. Workspace Probably doesn’t need a whole lot of explaining, the Workspace is the visual representation of the game, this is where you put all the instances that have to be rendered in the actual game. Players This container holds all of the player instances at runtime, this service should not be used for anything else. Lighting This container holds all information about the game it’s lighting information, back in the day this service was often used to store random pieces of game information, however in present day we have ReplicatedStorage for this. The only things that should be stored in Lighting are: Sky Atmosphere PostProcessingEffects MaterialService This service is part of the Custom Materials API. Note that this is currently in BETA and does not work in live games This should be used to insert custom materials you want to use in your game. ReplicatedFirst This service is similar to ReplicatedStorage except that the contents of ReplicatedFirst always are replicated before ReplicatedStorage. This service is ideal for making things that must run directly at the game startup, mainly loading screens. Theoretically any asset can be placed in here but take care about what you place in here, not everything has to be given this kind of priority. ReplicatedStorage This service is your general “dump” container, you can store anything you want in here. Note that this service unlike ServerStorage is available to both the server and the client. Examples are: Tools that you want to give players when you want to, but not in the StarterPack GUIs that you want to clone into the PlayerGui of any player from the client. RemoteEvents/RemoteFunctions ServerScriptService This service is used to hold all of your Scripts that have to run. I’m not going deep into whether you should put your scripts into here or in the Workspace, but my recommendation is keep anything that doesn’t have to interact with the game inside ServerScriptService and anything related to the physical world (e.x. Touched interactions) inside Workspace. You can also store all of the ModuleScripts in here, ServerStorage or ReplicatedStorage if you want but again this is a design choice, just keep in mind how your module itself replicates based on the service it’s in. ServerStorage This service is your general “dump” container, you can store anything you want in here. Note that this service unlike ReplicatedStorage is available to only to the server. Examples are: Reusable ModuleScripts Server side assets you want to clone elsewhere which the client is not allowed to see StarterGui This container is used to store all of the GUIs your game uses. These are: ScreenGui BillboardGui SurfaceGui Nothing else should be put into this container, often people store LocalScripts in here aswell but we have StarterPlayerScripts for this. Note: The contents are cloned to Players/{Player}/PlayerGui StarterPack This container holds all of the tools that all players obtain when they spawn in. Therefore this container should only contain tools, nothing else. There’s also a subfolder inside the Player called StarterGear, this is used in combination with StarterPack and is able to provide player specific gear. Note: The contents are cloned to Players/{Player}/Backpack StarterPlayer This service accomodates two subfolders which have two respective tasks, however this service itself also has a couple of functions. Firstly it defines all of the settings related to players when they spawn in, for example camera settings, standard walking speed and jump power, movement modes and much more. Additionally you can also insert two instances into here. Humanoid (Specifically named StarterHumanoid, used as the default Humanoid instance inside characters) Model (Specifically named StarterCharacter, used as the default character model) StarterPlayerScripts This is a subservice of StarterPlayer and contains LocalScripts which start to run when the player joins the game. Note: The contents are cloned to Players/{Player}/PlayerScripts StarterCharacterScripts This is a subservice of StarterPlayer and contains LocalScripts which start to run everytime you respawn. Note: The contents are cloned to Workspace/{Player} (the player character) Teams This service it’s sole purpose is to define Teams. Teams subdivide the players into groups of players. Nothing else should be put into this service. SoundScape This service contains sounds for the game that play independently of the Workspace, for example this can be used for cinematic background music that plays regardless of where you are on the map. You can insert SoundGroups and Sounds into here, SoundGroups are used to control settings like the Volume of all Sounds directly below it. Every Sound and SoundGroup is then able to include one or more SoundEffects. Chat This service is used to modify/extend the Lua Chat System. Normally you shouldn’t have to edit anything inside of here as the chat modules are all inserted at runtime, you can however copy the chat system and manually place it inside Chat in order to fork it and make changes, do note that this means you will lose out on any updates Roblox makes to it. The chat system allows you to extend it by using ChatModules, there’s two folders called ChatModules and ClientChatModules. You can insert these folders into the Chat and then provide custom extensions for the chat system. Important: Make sure you create a BoolValue called InsertDefaultModules inside these two folders and set it’s value to true or none of the default chat modules Roblox provides will be loaded! Other services that may appear There are some more vague services that can appear in the list which I will give a quick mention aswell. NetworkClient This only appears in Team Create instances and is only used to connect developers together to enable them to build together, this service can be ignored otherwise. LocalizationService This service can be used to insert LocalizationTables. These tables can either be manually uploaded through Studio but the intended use is to use the localization portal in the website. TestService This service is used by Roblox Engineers to perform analytical testing on the game. It can be used by developers but the functionality is very limited. The idea is you insert scripts into TestService which can be executed to check if certain conditions are correct. Remarks Note that if you want to insert anything into the explorer you can use the plus symbol next to whatever you’re trying to insert to and Roblox will give you one or more recommendations to insert into the given container, keep an eye on this as this will help you find the correct place to store your instances in."}]}