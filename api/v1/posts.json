[
  {
    "url": "/studio/2022/01/14/service-usages.html",
    "title": "Service usages",
    "category": "Studio",
    "excerpt": "The explorer in Roblox Studio contains a lot of “top level services”, all of those services have a specific function and are sometimes not used correctly.\nI’m going over all these services and define what they are supposed to be used for.\n\n",
    "content": "The explorer in Roblox Studio contains a lot of “top level services”, all of those services have a specific function and are sometimes not used correctly.\nI’m going over all these services and define what they are supposed to be used for.\n\nWorkspace\nProbably doesn’t need a whole lot of explaining, the Workspace is the visual representation of the game, this is where you put all the instances that have to be rendered\nin the actual game.\n\nPlayers\nThis container holds all of the player instances at runtime, this service should not be used for anything else.\n\nLighting\nThis container holds all information about the game it’s lighting information, back in the day this service was often used to store random pieces of game information, however in present day we have ReplicatedStorage for this.\nThe only things that should be stored in Lighting are:\n\n  Sky\n  Atmosphere\n  PostProcessingEffects\n\n\nMaterialService\nThis service is part of the Custom Materials API. Note that this is currently in BETA and does not work in live games\n\nThis should be used to insert custom materials you want to use in your game.\n\nReplicatedFirst\nThis service is similar to ReplicatedStorage except that the contents of ReplicatedFirst always are replicated before ReplicatedStorage.\n\nThis service is ideal for making things that must run directly at the game startup, mainly loading screens.\n\nTheoretically any asset can be placed in here but take care about what you place in here, not everything has to be given this kind of priority.\n\nReplicatedStorage\nThis service is your general “dump” container, you can store anything you want in here. Note that this service unlike ServerStorage is available to both the server and the client.\n\nExamples are:\n\n  Tools that you want to give players when you want to, but not in the StarterPack\n  GUIs that you want to clone into the PlayerGui of any player from the client.\n  RemoteEvents/RemoteFunctions\n\n\nServerScriptService\nThis service is used to hold all of your Scripts that have to run.\nI’m not going deep into whether you should put your scripts into here or in the Workspace, but my recommendation is keep anything that doesn’t have to interact with the game inside ServerScriptService and anything related to the physical world (e.x. Touched interactions) inside Workspace.\n\nYou can also store all of the ModuleScripts in here, ServerStorage or ReplicatedStorage if you want but again this is a design choice, just keep in mind how your module itself replicates based on the service it’s in.\n\nServerStorage\nThis service is your general “dump” container, you can store anything you want in here. Note that this service unlike ReplicatedStorage is available to only to the server.\n\nExamples are:\n\n  Reusable ModuleScripts\n  Server side assets you want to clone elsewhere which the client is not allowed to see\n\n\nStarterGui\nThis container is used to store all of the GUIs your game uses. These are:\n\n  ScreenGui\n  BillboardGui\n  SurfaceGui\n\n\nNothing else should be put into this container, often people store LocalScripts in here aswell but we have StarterPlayerScripts for this.\n\nNote: The contents are cloned to Players/{Player}/PlayerGui\n\nStarterPack\nThis container holds all of the tools that all players obtain when they spawn in. Therefore this container should only contain tools, nothing else.\n\nThere’s also a subfolder inside the Player called StarterGear, this is used in combination with StarterPack and is able to provide player specific gear.\n\nNote: The contents are cloned to Players/{Player}/Backpack\n\nStarterPlayer\nThis service accomodates two subfolders which have two respective tasks, however this service itself also has a couple of functions. Firstly it defines all of the settings related to players when they spawn in, for example camera settings, standard walking speed and jump power, movement modes and much more.\n\nAdditionally you can also insert two instances into here.\n\n  Humanoid (Specifically named StarterHumanoid, used as the default Humanoid instance inside characters)\n  Model (Specifically named StarterCharacter, used as the default character model)\n\n\nStarterPlayerScripts\nThis is a subservice of StarterPlayer and contains LocalScripts which start to run when the player joins the game.\n\nNote: The contents are cloned to Players/{Player}/PlayerScripts\n\nStarterCharacterScripts\nThis is a subservice of StarterPlayer and contains LocalScripts which start to run everytime you respawn.\n\nNote: The contents are cloned to Workspace/{Player} (the player character)\n\nTeams\nThis service it’s sole purpose is to define Teams. Teams subdivide the players into groups of players. Nothing else should be put into this service.\n\nSoundScape\nThis service contains sounds for the game that play independently of the Workspace, for example this can be used for cinematic background music that plays regardless of where you are on the map.\n\nYou can insert SoundGroups and Sounds into here, SoundGroups are used to control settings like the Volume of all Sounds directly below it.\n\nEvery Sound and SoundGroup is then able to include one or more SoundEffects.\n\nChat\nThis service is used to modify/extend the Lua Chat System.\n\nNormally you shouldn’t have to edit anything inside of here as the chat modules are all inserted at runtime, you can however copy the chat system and manually place it inside Chat in order to fork it and make changes, do note that this means you will lose out on any updates Roblox makes to it.\n\nThe chat system allows you to extend it by using ChatModules, there’s two folders called ChatModules and ClientChatModules.\nYou can insert these folders into the Chat and then provide custom extensions for the chat system.\n\nImportant: Make sure you create a BoolValue called InsertDefaultModules inside these two folders and set it’s value to true or none of the default chat modules Roblox provides will be loaded!\n\n\n\nOther services that may appear\nThere are some more vague services that can appear in the list which I will give a quick mention aswell.\n\nNetworkClient\nThis only appears in Team Create instances and is only used to connect developers together to enable them to build together, this service can be ignored otherwise.\n\nLocalizationService\nThis service can be used to insert LocalizationTables. These tables can either be manually uploaded through Studio but the intended use is to use the localization portal in the website.\n\nTestService\nThis service is used by Roblox Engineers to perform analytical testing on the game. It can be used by developers but the functionality is very limited.\nThe idea is you insert scripts into TestService which can be executed to check if certain conditions are correct.\n\n\n\nRemarks\nNote that if you want to insert anything into the explorer you can use the plus symbol next to whatever you’re trying to insert to and Roblox will give you one or more recommendations to insert into the given container, keep an eye on this as this will help you find the correct place to store your instances in.\n",
    "author": "Thodor12",
    "created": "2022-01-14T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/10/14/intro-to-threads.html",
    "title": "Intro to threads",
    "category": "Scripting",
    "excerpt": "There's a lot of misconceptions about threads in Lua(u). This article will explain the major parts that you need to know about threads.",
    "content": "There’s a lot of misconceptions about threads in Lua(u). This article will explain the major parts that you need to know about threads.\n\nLet’s start off by what is a thread? You can think of a thread as a piece of paper and on this paper is instructions. These instructions are the code you wrote which then the employee will execute these instructions. The employee in our case is our VM (Virtual Machine).\n\nHow do threads work?\n\nIn Lua, threads are ran concurrently not in parallel. This is the biggest misconception. Well, what’s the difference?\n\nConcurrent Execution: Execution of a thread at a single time while being able to switch thread execution.\nParallel Execution: Execution of two or more threads at a single time.\n\nLua being Lua, it is single-threaded, running 1 thread at a time. Though, it seems as if it is running multiple threads at a time because of how fast its execution is. This is all done by internal magic. The internal magic relies on a “queue” of threads.\n\nThe first thread gets thread execution and executes until it yields, when it yields it pauses thread execution for that thread and throws it in the back of the line. Then the next thread comes up and starts executing. This process is repeated until all threads have finished executing, or pretty much when all threads have “died”.\n\n\n\nIn this example you can see that Thread #1 was executing, it yielded, then passed execution over to Thread #2, it yielded or finished executing (died), and then passed execution back over to Thread #1 to finish executing.\n\nFun Fact: Roblox has implemented a beta stage of their multithreaded attempts using the Actor Model.\n\nHow do you make and run a thread?\n\nIn Luau, there are multiple ways of creating and running threads. In our case, we’re going to focus on coroutines.\n\nCoroutines are the most common ways of creating a thread.\nSimply by:\n\ncoroutine.create(function()\n    print(\"Hello World!\")\nend)\n\n\nNow, this only created the thread; it hasn’t executed the thread yet.\nTo do this, we can use task.spawn or coroutine.resume.\n\nlocal thread = coroutine.create(function()\n    print(\"Hello World!\")\nend)\n\ncoroutine.resume(thread) --&gt; Hello World!\n-- OR\ntask.spawn(thread)       --&gt; Hello World!\n\n\nTip: With task.spawn, you don’t need a thread, you can pass a function as well.\n\ntask.spawn(function()\n    print(\"Hello World\") --&gt; Hello World!\nend)\n\n\nThe difference here is that coroutine.resume is native to Vanilla Lua and that task.spawn communicates directly with the task scheduler and runs at 60hz.\n\nThere is a second method using coroutines, coroutine.wrap, the only thing with this function is that it propagates errors to the output coming from the calling thread which terminates the calling thread instead of the created thread.\n\nE.x.\n\ncoroutine.wrap(function()\n    print(\"Hello World!\") --&gt; Hello World!\nend)()\n\n\nYou might be asking why are there two parentheses () at the end? Well, coroutine.wrap returns a function, more specifically a closure of the created thread which can be called to resume the thread.\n\nWhich you can then do..\n\nlocal closure = coroutine.wrap(function()\n    while true do\n        print(\"Hello World!\")\n        coroutine.yield()\n    end\nend)\n\nclosure() --&gt; Hello World!\nclosure() --&gt; Hello World!\nclosure() --&gt; Hello World!\n\n\nNow, you might be asking “what is coroutine.yield() and why is it there?”\n\nWell, the function name itself is self-explanatory. It will just yield the thread it was called in. This means that our thread is now suspended not dead. We do this because you cannot resume a dead thread. Once a thread is dead, it cannot be “revived” or resumed. Suspended threads, however, can by either calling the closure from coroutine.wrap or calling coroutine.resume passing in your thread.\n\nWhen a yielded thread becomes resumed, either by Roblox or manually, it will resume where it was yielded.\nSo in our case:\n\nlocal thread = coroutine.create(function()\n    while true do\n        print(\"Hello World!\")\n        coroutine.yield() --// When thread is resumed, the thread execution will start here from where it was yielded.\n    end\nend)\n\ncoroutine.resume(thread) --&gt; Hello World!\ncoroutine.resume(thread) --&gt; Hello World!\ncoroutine.resume(thread) --&gt; Hello World!\n\n\nWhy multiple threads in one script?\n\nThreads are useful for when you want blocking code to execute differently from the rest of your code. An example could be an infite while true do loop that constantly checks for a condition while the rest of your executes normally, not being blocked.\n\nE.x.\n\nlocal a = 0\n\nlocal blockingCode = coroutine.create(function()\n    while true do\n        if a &gt; 10 then\n            print(\"Not there yet\")\n        else\n            print(\"We're here!\")\n        end\n        a += 1\n        task.wait() -- task library's supersede of wait()\n    end\nend)\n\ntask.spawn(blockingCode)\n\n--... // Rest of this code runs, while the \"blockingCode\" thread is yielding.\n-- The \"blockingCode\" thread will resume execution whenever the main thread finishes its execution.\n\n",
    "author": "Pog Chonk",
    "created": "2021-10-14T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/10/09/startergui.html",
    "title": "Using StarterGui",
    "category": "Scripting",
    "excerpt": "StarterGui is a service which lets you clone GUI’s to any player their PlayerGui folders, however you should avoid using it in code directly.\n\n",
    "content": "StarterGui is a service which lets you clone GUI’s to any player their PlayerGui folders, however you should avoid using it in code directly.\n\nHow does StarterGui work?\nStarterGui itself doesn’t actually contain the GUI’s that the player gets to see. StarterGui is purely a container which is there to clone\nall it’s contents to the Player their PlayerGui everytime they spawn in.\n\nThese GUI’s are essentially templates and nothing more.\n\nWhy should I not use them in my code?\nSometimes people want to manipulate something on their GUI, but they don’t see the changes appearing, why?\n\nMost of the time this is due to people manipulating the GUI inside StarterGui, as said before these are only templates.\nThe changes are not being made to your actual current GUI but to the template, this means you’ll only see the changes if you die and respawn.\nIf that happens the GUI gets cloned again from StarterGui back to your PlayerGui, at which point you’ll see the changes.\n\nThe solution\nIt’s actually really easy, we discussed before that StarterGui gets cloned to PlayerGui, so when you want to manipulate the GUI you have to\nfind the current GUI inside your own player it’s PlayerGui.\n\nFor example you can replace:\n\nlocal myGui = game:GetService(\"StarterGui\").MyGui\n\n\nwith:\n\nlocal myGui = game:GetService(\"Players\").LocalPlayer.PlayerGui.MyGui\n\n\nThere’s also an alternative, this is to simply keep the scripts that manipulate the GUI inside of your actual GUI instance.\nThis way you can just refer to the GUI and any descendants of the GUI by using script.Parent, which is relative to your script.\nLocalscripts only run when they are a descendant of the player, not if they are inside StarterGui. Which means it doesn’t attempt to mess\nwith your GUI’s inside StarterGui.\n",
    "author": "Thodor12",
    "created": "2021-10-09T00:00:00+00:00"
  },
  {
    "url": "/studio/2021/10/09/script-types.html",
    "title": "Script types",
    "category": "Studio",
    "excerpt": "Roblox has multiple different script types, understanding the differences and where you can use them is essential for developing your games.\n\n",
    "content": "Roblox has multiple different script types, understanding the differences and where you can use them is essential for developing your games.\n\nAll script types\nRoblox has three main script types that you need to know:\n\nScript\nThe first one is the simple Script, also sometimes referred to as ServerScript or NormalScript.\nThese scripts run on the server, indepently of all clients. They start running as soon a server is started.\n\nScripts can run in the following places:\n\n  Workspace\n  Players (inside a specific player, for example the backpack)\n  ServerScriptService\n\n\nLocalScript\nA LocalScript is the opposite of your regular Script, this one runs on the client (per player) as opposed to the server.\nThese scripts are able to access game:GetService(\"Players\").LocalPlayer to know which client (player) the script is running for.\n\nLocalScripts can run in the following places:\n\n  Workspace (as a child of the player it’s character)\n  Players (inside a specific player, for example the backpack)\n  ReplicatedFirst\n\n\nLocalScripts also have two services that they are unable to read/access:\n\n  ServerScriptService\n  ServerStorage\n\n\nBoth of these services are not replicated to the client and thus the client can’t see anything in these services.\n\nModuleScript\nModuleScripts are a special case, these scripts cannot run on their own and have to be required by either a Script or a LocalScript in order to run.\nIt doesn’t matter where you save these scripts but the general consensus is to put them either inside ServerStorage or ReplicatedStorage, the only thing that matters\nis that the script which is supposed to require the module can actually access it (for example LocalScripts cannot require modules inside ServerStorage, as they cannot see this service).\n\nAs discussed before both script types also have some restrictions on what they are able to do (for example LocalPlayer).\nModuleScripts inherit these restrictions based on what type of script they are required by, we’ll delve deeper into this in the next section.\n\nCoreScript\nAlthough these scripts cannot be created and are managed by Roblox, it’s good to know that they exist because they also come with their own permission level\nand have a more broad API which a lot of them normal scripts cannot access, for example CreateLocalPlayer.\n\nPermission levels\nEach script type comes with a different set of permissions, this is how the API distinquishes which script is able to use certain services or methods.\nFor example only Scripts have access to DataStoreService and HttpService, whereas only LocalScripts can use UserInputService and ContextActionService.\n\nThese permission levels can for the most part be found on the API documentation, where sometimes it says “xxxSecurity”. For example on the previously shown CreateLocalPlayer page you can see on the top it says “LocalUserSecurity”. This means it can only be called by the core or the command bar. Not inside (Local)Scripts nor plugins.\n\nYou can find in-depth information about all permission levels here.\n\nAdditionally you can find the entire API dump here so you can quickly see the security read &amp; write permissions that are needed for the entire API here.\n",
    "author": "Thodor12",
    "created": "2021-10-09T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/10/09/events-vs-polling.html",
    "title": "Events vs polling",
    "category": "Scripting",
    "excerpt": "Roblox is an event-driven system, but what does this entail exactly?\n\n",
    "content": "Roblox is an event-driven system, but what does this entail exactly?\n\nEvent-driven vs polling\nWhat does this mean exactly?\n\n\n  Event-driven is when you rely on events to trigger certain pieces of code, for example callback functions.\n  Polling is where you use continuous checks to see if a certain condition is met and then taking action.\n\n\nJust from reading that it shouldn’t be hard to guess that event-driven solutions are better because it simply won’t require continuous checks.\nHowever do note in some cases a polling system is necessary whether you like it or not.\n\nBut how do I use events?\nSay you need to update your text on a GUI based on a leaderstats value.\nA polling example would look something like this:\n\nlocal value = game:GetService(\"Players\").LocalPlayer.leaderstats.MyValue\n\nwhile true do\n    script.Parent.Text = value.Value\n    task.wait()\nend\n\n\nAlthough this works this has a big flaw, unnecessary updates. Most of the time your value likely isn’t even updating, so you are continuously\nsetting the Text of your TextLabel even though there’s no change at all, this is a waste of performance.\nAn event driven system can fix it by doing this:\n\nlocal value = game:GetService(\"Players\").LocalPlayer.leaderstats.MyValue\n\nvalue.Changed:Connect(function()\n    script.Parent.Text = value.Value\nend)\n\n\nThis will only update the Text of the TextLabel whenever a change occurs in the value object. Roblox has events for this (they are called RBXScriptSignals)\nand they have a :Connect method, :Connect takes a single argument, a callback function.\nThis function is fired by the Roblox engine whenever the event is fired either internally or by other means.\n\nEvents come in all sorts of forms, be it changed listeners on instances, events like PlayerAdded/CharacterAdded or even manually callable events like Remote/Bindable events.\n\nLike I said before it’s not always sunshine, there are cases where you most definitely need to do something continuously.\nThis comes mostly into play when working with physics, for example movement.\n\nRoblox has a limit when it comes to changed events, they are only triggered on direct property assignments, but physics updates do not trigger changed events.\nThis means that if you need to check for changes in the MoveDirection of the Humanoid you will find yourself needing a polling solution to constantly\nread out the MoveDirection property, you can do this either by using while loops, or preferably by using RunService.\nFor example:\n\n-- Localscript inside of the character\nlocal humanoid = script.Parent.Humanoid\n\nhumanoid:GetPropertyChangedSignal(\"MoveDirection\"):Connect(function() -- this will never fire because it's updated through physics\nend)\n\ngame:GetService(\"RunService\").RenderStepped:Connect(function(step)\n    print(humanoid.MoveDirection)\nend)\n\n\nEven though you must do something like this, it doesn’t mean you can build an event-driven system on top of this if you really want to.\nA changed event for example only has to check if the previous value doesn’t match the current value, and then trigger a function.\nFor example:\n\n-- Localscript inside of the character\nlocal humanoid = script.Parent.Humanoid\nlocal lastDirection = humanoid.MoveDirection\n\nfunction moveDirectionUpdated()\n    print(\"Move direction updated\")\nend\n\ngame:GetService(\"RunService\").RenderStepped:Connect(function(step)\n    if lastDirection ~= humanoid.MoveDirection then\n        moveDirectionUpdated()\n    end\n    lastDirection = humanoid.MoveDirection\nend)\n\n\nEven though this is backed by a polling system you can still filter out the bulk of the work that needs to be done only when it’s necessary.\n",
    "author": "Thodor12",
    "created": "2021-10-09T00:00:00+00:00"
  },
  {
    "url": "/studio/2021/10/05/packages-in-roblox.html",
    "title": "Packages: What are they?",
    "category": "Studio",
    "excerpt": "As your game continues to develop and get larger in assets, you may start to realize (or not) that you have the same scripts in different assets in your game, and once you begin to lose track of these assets keeping track of them will get very difficult soon.\n\n",
    "content": "As your game continues to develop and get larger in assets, you may start to realize (or not) that you have the same scripts in different assets in your game, and once you begin to lose track of these assets keeping track of them will get very difficult soon.\n\nSo, how could you solve this problem? Well thankfully, Roblox has introduced us a feature called, Packages. And no, these aren’t the packages that make you look nice and strong, but these are the packages that allow you to make commits to your scripts (or even physical objects) and be able to publish to other places, update other packages, and view the changes to these packages.\n\nIn this post, I’ll be showing you how to use packages, why should you use them, and other cases for them.\n\ndisclaimer: this post was referenced off of the Roblox Packages – Reusable Game Assets article provided by the Roblox Developer Resources site.\n\nSetting Up Your Workspace\n\n  Open up a new empty Baseplate. (optional: set ClockTime to 0)\n  Create three new Parts\n    \n      Name your either of your three parts to Red, Green, and Blue. (optional: space them out at least 10 studs)\n      Change the colors of the parts to either Really red,  Lime green, or Really blue.\n      Insert a SurfaceLight into each part and apply these changes to its properties.\n        \n          Angle: 10\n          Brightness: 20\n          Range: 6\n        \n      \n    \n  \n  Create a Script inside of the Red part.\n\n\nEditing the Example Script\nSo in this new script we’ve created in the Red part, we’re going to add a simple piece code.\n\nlocal Part = script.Parent\nlocal Light = Part.SurfaceLight\n\nPart.Color = Light.Color\n\n\nsimple, right?\n\nGo ahead and press Run (or F8) and check that the code works, if not, check the instructions below. Then copy the script and paste it into the other two parts, Green and Blue. Press Run again to ensure all the SurfaceLights match up with the part’s color.\n\nThen, in the Red part, open the script again and add these changes.\n\nlocal Part = script.Parent\nlocal Light = Part.SurfaceLight\n\nPart.Color = Light.Color\nPart.Material = Enum.Material.Neon\nPart.Size = Vector3.new(5, 5, 5)\n\n\nJust like before, press Run and ensure the code works and after that copy the modified script and overwrite the previous scripts inside of the other two parts.\n\nCreating a Package\nNow that we’ve gotten the easy part out of way, you may begin to see how tedious this process could be, manually updating every script and keeping track of them. That’s why packages will come in handy when these type of situations happen as you develop your game.\n\nSo let’s create our first package! (keep in mind that packages save into your inventory)\n\n  Right-click the script located in the Red part. (or either of the three, just know that it’ll be the script you’ll create changes inside of)\n  Click Convert to Package... from the menu.\n    \n      As you do that, a dialog window will appear. Fill out the Title to Test Package or anything you’d like.\n      Press Submit.\n    \n  \n  Once you’ve submitted, you should see something called PackageLink inside the script. That’s a way to know you’ve successfully created your own package!\n\n\nAccessing Your Packages and Inserting Them\nThere are two places where you can access your packages, Toolbox or the Packages folder located in Asset Manager.\n\nNow for our convienience, we’ll be accessing our packages via Asset Manager. If you don’t know where it is, right-click on the ribbon (if not there, Ctrl + F1), and click on Asset Manager.\n\nAccess the new package inside of the Packages folder and you should be able to see the package that you just created. From here, delete the scripts located in the other two parts which do not have a PackageLink inside of them, and then insert the package into each part.\n\nCommitting Changes to Packages\nIt doesn’t matter which package you edit from as long as it’s the same as the others. Now that we have multiple packages, let’s figure out how to commit changes to all of the packages in the game. (you can also update packages in other games as long they’re the same and the permissions are met)\n\nFirst, let’s add some revisions to our code. Open the package and edit the code to this.\n\nlocal Part = script.Parent\nlocal Light = Part.SurfaceLight\n\nPart.Color = Light.Color\nPart.Material = Enum.Material.Neon\nPart.Size = Vector3.new(5, 5, 5)\nPart.Transparency = 0.8\n\nLight.Brightness = 40\n\n\nAs you edit the code, you’ll start to see an orange dot \n on the left of the package’s name in the Toolbox. This indicates that there has been a change made to the code and it’s most likely different from the current published version of the package.\n\nExit out of the script tab and let’s start commiting these changes.\n\n  Right-click the edited package.\n  Click Publish Changes to Package.\n  A prompt will appear noticing you about the change you are about to publish.\n    \n      If you don’t want to see this dialog everytime you publish a change to a package, tick the box. (not recommended)\n    \n  \n  Press Publish when you are ready.\n\n\nCongratulations, you’ve successfully published your first package.\n\nUpdating Packages\nOnce you’ve updated a package, you want to also update the other packages now that they are considered outdated .\nThere are two methods to updating your packages. Method 1 being updating all of them at once and Method 2 is updating the other packages one at a time.\n\nMethod One\n\n  Right-click a package that has been updated to the latest version.\n  Click Update All.\n  You will see a dialog appear.\n    \n      There are four things to discuss here. (Version, Published On, Places, and Submit/Cancel)\n        \n          Version: Shows the current version number.\n          Published On: Shows when the current version was last published.\n          Places: These are the places that have the current package inside the game. You have the option to publish these packages in those games.\n          Submit/Cancel: Self-explanatory.\n        \n      \n    \n  \n  Submit the update.\n\n\nMethod Two\n\n  Locate the outdated package \n you’d like to update.\n  Right-click the package.\n  Click Get Latest Package.\n  A prompt will appear. (read the notice in Committing Changes to Packages)\n  Click Get Latest.\n\n\nYou’ve successfully updated your packages. Congrats!\n\nViewing the Changes on a Package\nLet’s say somebody in your team, or you wanted to know what changes were made to the package. Well you can see what changes you’ve made with a few simple steps.\n\n  Right-click the unpublished package or outdated package. (you’ll know if a package is unpublished by the orange dot  / sync \n indicator)\n  Click View Script Changes....\n\n\nThat was pretty simple, but what are we looking at?\n    - Anything highlighted in red means that it was taken out or modified.\n    - Anything highlighted in green means it was added in or modified.\n\nConclusion\nWell it’s been a long read but that covers the basics of packages. There’s not much left other than reverting changes to a package(s). Let’s cover what you were able to do.\n\n\n  Create a package.\n  Update a package and the methods to do so.\n  View changes in a package.\n\n\nIf you have any questions regarding packages, don’t be afraid to ask in the Discord. Thank you for reading and have fun programming!\n",
    "author": "TheePBHST",
    "created": "2021-10-05T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/09/28/diff-nil-void.html",
    "title": "The difference between nil and \"void\"",
    "category": "Scripting",
    "excerpt": "A common misconception in Lua is that functions have an implicit return value. This is not true. Functions have an implicit return instruction, meaning a function will always return after execution even if no return is specified. This implicit return instruction will never carry any value.\n\n",
    "content": "A common misconception in Lua is that functions have an implicit return value. This is not true. Functions have an implicit return instruction, meaning a function will always return after execution even if no return is specified. This implicit return instruction will never carry any value.\n\nThis is not to be confused with nil, however. For the sake of explanation, we will call this complete absence of value void. The source code for Lua 5.1 refers to it as None but void is a much more common term in the world of programming.\n\nThe difference between the two comes from the way emptiness is represented in Lua. nil is a value that represents the absence of a value. It is possible to work with nil in Lua because it is a native datatype. For the sake of the analogy we will call nil a “tangible nothing.” It is a value that we can use that represents nothing. void on the other hand, is an “intangible nothing.” Lua does not comprehend this lack of value because it was designed to use nil as a lack of value. The only way to detect this nothingness is through C functions. Take this for example:\n\nlocal function returnsVoid()\n\t-- nothing here! return instruction is auto generated.\nend\n\nlocal function returnsNil()\n\treturn nil\nend\n\nprint(select(\"#\", returnsVoid())) --&gt; 0\nprint(select(\"#\", returnsNil())) --&gt; 1\n\n\nselect is a function with some overloads, the one we’re using simply counts the number of arguments passed to it and returns it.\n\nAs we can see, there is a detectable difference. However, in most cases this void will end up being coerced into nil because it makes more sense to the user. This begs the question, “If void is coerced into nil most of the time, why does it matter?” This is the beautiful part. For the most part, it really doesn’t matter! There is a few cases where it can come back to bite you though.\n\nLet’s reuse the functions we defined earlier for this next example.\n\nlocal t = {1,2,3}\n\ntable.insert(t, returnsNil()) --&gt; while generally useless, this code is safe and causes no issues.\n\ntable.insert(t, returnsVoid()) --&gt; this will error during runtime because table.insert is an overloaded function! \n-- it expects 2 or 3 arguments but since void is a complete absence of value, it only sees table.insert(t)\n\n\nA Roblox related example of this difference is in the function Instance:GetAttribute(). It has the capability to return void which comes with the same problems as the above example.\n",
    "author": "artblart",
    "created": "2021-09-28T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/09/01/logical-operators-short-circuiting.html",
    "title": "Logical operators, and their short circuiting behavior",
    "category": "Scripting",
    "excerpt": "A key part into learning how to use pseudo ternaries in Lua(u) is understanding how each part of it works, and this was written especially for that. But, before we get into the workings of logical operators and their short circuiting behavior, the truthyness and falsyness of values needs to be covered first.\n\n",
    "content": "A key part into learning how to use pseudo ternaries in Lua(u) is understanding how each part of it works, and this was written especially for that. But, before we get into the workings of logical operators and their short circuiting behavior, the truthyness and falsyness of values needs to be covered first.\n\nWhat does it mean for something to be truthy or falsy?\nSince the truthyness and falsyness of values in Lua(u) should be understood before diving into the world of logical operators, the following is a brief overview:\n\n\n  \n    Falsy For something to be considered falsy, it has to evaluate to nil or false. If you’re not sure of what nil is, it’s a data type that represents nothing. The only examples of falsy values are nil and false.\n  \n  \n    Truthy For something to be considered truthy, it must not be falsy. Examples of truthy values are numbers, strings, tables, and anything else that’s not falsy.\n  \n\n\nDo keep in mind that the truthyness and falsyness of values vary depending on the programming language you’re working with. That is, a value considered truthy in one programming language may be falsy in another and vice versa.\n\nWhat are the logical operators?\nUsually, an operator has at least one value it operates on, which are its operands. For example, in the expression 1 + 14, 1 and 14 are the operands. And if you aren’t already aware, there’s three logical operators you can work with:\n\n\n  &lt;firstOperand&gt; or &lt;secondOperand&gt; The logical or operator operates on two operands. or only wants one of its operands to be truthy. If the &lt;firstOperand&gt; is truthy, then it’s evaluated and returned, without evaluating the &lt;secondOperand&gt;. However, if the &lt;firstOperand&gt; is falsy, then the &lt;secondOperand&gt; is evaluated and returned. Here’s some examples:\n\n\n-- 15 is &lt;firstOperand&gt;.\n-- 16 is &lt;secondOperand&gt;.\nprint(15 or 16) -- Prints 15 because 15 is truthy.\n\n-- false is &lt;firstOperand&gt;.\n-- 15 is &lt;secondOperand&gt;.\nprint(false or 15) -- Prints 15 because false is falsy.\n\n-- CHALLENGE #1:\n-- Can you figure out what this would print?\nprint(false or (16 or 15))\n\n\n\n  &lt;firstOperand&gt; and &lt;secondOperand&gt; Likewise to or, the logical and operator operates on two operands as well. The difference being that and wants both of its operands to be truthy. If the &lt;firstOperand&gt; is truthy, then the &lt;secondOperand&gt; is evaluated and returned. However, if the &lt;firstOperand&gt; is falsy, then it’s evaluated and returned, without evaluating the &lt;secondOperand&gt;. Here’s another set of examples:\n\n\n-- 14 is &lt;firstOperand&gt;.\n-- 15 is &lt;secondOperand&gt;.\nprint(14 and 15) -- Prints 15 because 14 and 15 are truthy.\n\n-- nil is &lt;firstOperand&gt;.\n-- 16 is &lt;secondOperand&gt;.\nprint(nil and 16) -- Prints nil because nil is falsy.\n\n-- CHALLENGE #2:\n-- Can you figure out what this would print?\nprint((\"Cool.\" and \"Epic.\") and \"You’re cool and epic!\")\n\n\n\n  not &lt;operand&gt; Unlike the others, the logical not operator only operates a single &lt;operand&gt;. Being the simplest of them all, all not does is invert its &lt;operand&gt;.  If the &lt;operand&gt; is truthy, then not &lt;operand&gt; returns false. However, if the &lt;operand&gt; is falsy, then not &lt;operand&gt; returns true. Here’s the last set of examples:\n\n\n-- 15 is &lt;operand&gt;.\nprint(not 15) -- Prints false because 15 is truthy.\n\n-- nil is &lt;operand&gt;.\nprint(not nil) -- Prints true because nil is falsy.  \n\n-- CHALLENGE #3:\n-- Can you figure out what this would print?\nprint(not (not (false and 15)))\n\n\nExample usage of NOT\nLet’s say you have a guiObject which you want to toggle its Visible property’s value on and off each time a guiButton is clicked. A naive solution would be:\n\nguiButton.MouseButton1Click:Connect(function()\n    if guiObject.Visible then\n        guiObject.Visible = false\n    else\n        guiObject.Visible = true\n    end\nend)\n\n\nAn alternative and more concise solution, however, would be:\n\nguiButton.MouseButton1Click:Connect(function()\n    guiObject.Visible = not guiObject.Visible\nend)\n\n\nThe example above would work because let’s say that the guiObject.Visible property’s value starts off as true, meaning it’s visible. If you click the guiButton, not would invert true and the result would be false because true is truthy. Then, the guiObject.Visible property’s value is set to false, meaning it’s invisible. If you click the guiButton again, not would invert false and the result would be true because false is falsy.\n\n-- guiObject.Visible’s value starts off true.\n-- FIRST CLICK:\nguiObject.Visible = not guiObject.Visible\n\n-- Which becomes:\nguiObject.Visible = not true\n\n-- Which becomes:\nguiObject.Visible = false\n\n\n-- SECOND CLICK:\nguiObject.Visible = not guiObject.Visible\n\n-- Which becomes:\nguiObject.Visible = not false\n\n-- Which becomes:\nguiObject.Visible = true\n\n\nSo as you click the guiButton, this pattern repeats.\n\nShort circuiting with logical operators\n\nAs mentioned earlier, when the &lt;firstOperand&gt; of or is truthy, it’s evaluated and returned, without evaluating the &lt;secondOperand&gt;. And it was also mentioned, when the &lt;firstOperand&gt; of and is falsy, it’s evaluated and returned, without evaluating the &lt;secondOperand&gt;. This idea of or and and only evaluating what it needs depending on the truthyness or falsyness of its operands is called short circuit evaluation or short circuiting, for short.\n\nAn important thing to keep in mind is that although this section focuses on short circuiting with the logical operators, short circuiting isn’t just limited to them. That is, if-elseif statements can also short circuit their conditions.\n\nPseudo Ternary\nIMPORTANT UPDATE: Roblox now officially supports ternary like operations, see here\n\nSome programming languages provide direct support for something called the ternary ? operator, or ternary, for short. However, Lua(u) doesn’t. Nonetheless, you can think of the ternary as a shorthand, for using if-else statements, that operates on three operands. Here’s its general syntax:\n\n-- &lt;firstOperand&gt; ? &lt;secondOperand&gt; : &lt;thirdOperand&gt;\n-- Where:\n-- &lt;firstOperand&gt; is the condition being tested.\n\n-- &lt;secondOperand&gt; is the expression that’s evaluated \n-- and returned if the condition is truthy.\n\n-- &lt;thirdOperand&gt; is the expression that’s evaluated\n-- and returned if the condition is falsy.\n\n\nSo its syntax can also be expressed as:\n\n-- &lt;conditionExpression&gt; ? &lt;truthyExpression&gt; : &lt;falsyExpression&gt;\n\n\nNow, as mentioned before, Lua(u) doesn’t provide direct support for the ternary. However, by using the logical and and or operators and their short circuiting behavior, together, it’s possible to get behavior similar to the ternary. Pseudo just means fake. So, this is why it’s called the pseudo ternary operator or pseudo ternary, for short. Here’s what its syntax looks like:\n\n-- &lt;firstOperand&gt; and &lt;secondOperand&gt; or &lt;thirdOperand&gt;\n\n-- Or if you prefer:\n-- &lt;conditionExpression&gt; and &lt;truthyExpression&gt; or &lt;falsyExpression&gt;\n\n\nAs you can see, the pseudo ternary syntax is not far from the actual ternary syntax. So, once again, here’s the way it works:\nIf the &lt;firstOperand&gt; or &lt;conditionExpression&gt; is truthy, then the &lt;secondOperand&gt; or &lt;truthyExpression&gt; is evaluated and returned as the first operand of or. Since the &lt;secondOperand&gt; or &lt;truthyExpression&gt; is expected to be truthy, it’s evaluated and returned.\n\nHowever, if the &lt;firstOperand&gt; or &lt;conditionExpression&gt; is falsy, then it’s also evaluated and returned as the first operand of or. But here’s where things change. Since the first operand of or is falsy, the &lt;thirdOperand&gt; or &lt;falsyExpression&gt; is evaluated and returned. Here’s some examples:\n\nlocal x = 15\n\n-- x == 15 is &lt;firstOperand&gt; or &lt;conditionExpression&gt;.\n-- “15 is a cool number.” is &lt;secondOperand&gt; or &lt;truthyExpression&gt;.\n-- “But this number is cooler” is &lt;thirdOperand&gt; or &lt;falsyExpression&gt;.\n-- Prints “15 is a cool number.” if x == 15.\nprint(x == 15 and \"15 is a cool number.\" or \"But this number is cooler.\")\n\n-- CHALLENGE #4:\n-- Can you figure out what this would print if part.Anchored == true?\nprint(part.Anchored and \"Anchored\" or \"Unanchored\")\n\n\nCaveats\n\nWhy pseudo ternaries won’t always work\nUnfortunately, pseudo ternaries will never work the exact same way as the actual ternary is because when the &lt;secondOperand&gt; or &lt;truthyExpression&gt; is falsy, the &lt;thirdOperand&gt; or &lt;falsyExpression&gt; is evaluated and returned which is because of how or works.\n\nFor this reason, it’s recommended that when you have a falsy expression in the place of the &lt;secondOperand&gt; or &lt;truthyExpression&gt; that you use if statements instead.\n\nAs an alternative solution, you can use not to invert the &lt;secondOperand&gt; or &lt;truthyExpression&gt; so that it’s a truthy expression, as it’s expected to be. However, doing that would only add the complexity of the issue. Therefore, the first solution is better.\n\nPseudo ternaries vs if statements\nA lot of the time if statements can be replaced by pseudo ternaries, however, this doesn’t mean that you should always do this. Overusing pseudo ternaries for the sake of reducing the amount of if statements (and for this reason, the amount of lines) is a bad practice to follow.\n\nUse pseudo ternaries in places where it would improve the readability of your code to you, your future self and other programmers as well. Because at the end of the day, your code its readability should generally be prioritized over its size.\n",
    "author": "steve15",
    "created": "2021-09-01T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/08/29/findfirstchild.html",
    "title": "FindFirstChild and WaitForChild",
    "category": "Scripting",
    "excerpt": "There’s some pretty big differences between FindFirstChild and WaitForChild which you have to understand in order to properly use them.\n\n",
    "content": "There’s some pretty big differences between FindFirstChild and WaitForChild which you have to understand in order to properly use them.\n\nFindFirstChild\nWhen using FindFirstChild you are not guaranteed to actually get a result, this is because it attempts to find the first child with the given name.\nIf this child does not exist it returns nil. Note that this method also doesn’t wait for a child to appear. If the child isn’t present at the time FindFirstChild runs\nit’s either just not present at all, or if you assume it has to be present it could be it’s not replicated from the server yet.\n\nThis means that constructions where you directly access the result of FindFirstChild like:\nprint(parent:FindFirstChild(\"Child\").Name)\n\nare not guaranteed to work and can potentially run into errors at runtime.\n\nYou need to make sure that you properly check if the result is not nil before using the result:\nlocal child = parent:FindFirstChild(\"Child\")\nif child ~= nil then\n  print(child.Name)\nend\n\n\nWaitForChild\nUnlike FindFirstChild, WaitForChild is guaranteed to always return an instance, however it yields the current thread until a child with the given name is present.\n\nWaitForChild also allows you to pass a number as the second argument which defines the timeout. This means WaitForChild will only wait for an x amount of seconds.\nIf you use this parameter then WaitForChild can return nil too, just like FindFirstChild.\n\nAdditionaly WaitForChild also drops warnings in the output: “Infinite yield possible …”, this means WaitForChild has already been yielding for 5 seconds already without\nbeing able to get a result already. Most of the time this means that the instance you were expecting to load doesn’t actually exist.\nIn some rare cases it’s actually possible that it would take more than 5 seconds to load.\n\nNote that this warning is not thrown when you provide the timeout parameter.\n",
    "author": "Thodor12",
    "created": "2021-08-29T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/08/20/touched-how-to-use-it.html",
    "title": "Touched, how to use it and it's limitations",
    "category": "Scripting",
    "excerpt": "Touched is an event which you can use to detect whenever a part gets touched by a different part, however people often claim this is too inaccurate and that’s for a good reason.\n\n",
    "content": "Touched is an event which you can use to detect whenever a part gets touched by a different part, however people often claim this is too inaccurate and that’s for a good reason.\n\nUsage\n\nLike said before, Touched is an event, which means you have to use :Connect in order to use it, here’s an example:\nlocal part = script.Parent\n\npart.Touched:Connect(function(otherPart)\n  print(part .. \" got touched by \" .. otherPart)\nend)\n\nNow this isn’t very difficult and very simple to use, however it’s more important on what parts you set your Touched listeners on, we’ll go deeper into this at the limitations.\nSometimes parts don’t always trigger the Touched event, take for example a part you are supposed to jump on top of,\nit’s important to to know that if you want Touched to fire more reliably you have to make bigger parts surrounding the actual part, hitbox parts.\nYou do this to give Touched some more breathing room to be able to fire properly.\n\nLimitations\n\nAs said before Touched isn’t perfect, but that’s most of the time due to improper usage or absurd expectations from the developer side.\nA Touched event has to rely on two or more instances intersecting during the physics calculation step of the current frame.\nThat condition doesn’t seem too difficult to hit, however take into consideration that for you, the end user, everything in the game looks smooth,\nhowever for the engine itself that’s not the case.\n\nWhen the engine calculates the intersections it just takes the current known position of the part, it doesn’t check every viable position since the last known position in the\nprevious frame and attempts to find intersection points.\nThis means that if parts move too fast an intersection can be missed, see the image below.\n\n\n\nFor clarification the gray parts are parts with Touched listeners.\nThe black lines are trajectories of parts moving around in the workspace.\nThe red lines are when a physics step occurs, the places where an intersection is calculated.\n\nNow what really goes on in this image, the black line is basically what we see, we assume by looking at the black line that we get an intersection.\nHowever in truth this doesn’t happen, as we explained before intersections are calculated during the physics steps (the red lines).\nThe engine doesn’t take into consideration where it previously came from or the part it travelled, it only knows the current point it’s at.\nTherefore it’s possible that at the time the physics step takes place, there’s no ongoing intersection between two parts.\nThis can be caused by 3 common issues:\n\n  Too small parts\n  Too high velocity\n  No big enough intersection area\n\n\nIn case of the first one the parts are not big enough in order to get an intersection, this goes hand in hand with the second one, velocity.\nWhen parts move too fast the distance between the red lines becomes longer, meaning there’s more potential for intersections to get skipped.\nThe last one applies to the left side of the image, when there’s practically no intersection area (surface touch), it gives Touched almost no capability to fire.\n\nHow to fix these issues\nWe’ve already named the fixes in the previous section. You have to make sure your parts are big enough and don’t travel too fast so they have a chance to intersect with other parts.\nAdditionally you can also make sure the parts have to be Touched are bigger, that way you can improve your chances too.\n",
    "author": "Thodor12",
    "created": "2021-08-20T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/08/17/understanding-scope.html",
    "title": "Understanding Scope",
    "category": "Scripting",
    "excerpt": "A scope is a section of code where a variable is defined, in a valid state, and the variable is visible.\ne.x.\n\n",
    "content": "A scope is a section of code where a variable is defined, in a valid state, and the variable is visible.\ne.x.\n\ndo\n  local x = \"banana\"\n             --| X was declared in this scope, cannot be accessed in outer scopes, but can be accessed in inner scopes.\n  print(x) --&gt; banana\nend\n\nprint(x) --&gt; nil\n\n\nGlobal VS Local Variables\nA local variable has the lifetime of the scope they’re declared in and are locked to that scope and inner scopes.\nA global variables lifetime is the time the script is running; it is not locked to any scope.\ne.x.\ndo\n  local x = \"banana\" -- Local Variable\n  -- X's lifetime is dependent on this scope since it's declared here.\n  y = \"apple\" -- Global Variable\n  -- Y's lifetime is only dependent on the runtime of the script.\nend\n\nprint(x) --&gt; nil\nprint(y) --&gt; apple\n\n\nThis applies with functions too, functions declared via local function foo() is almost like doing local foo = function() end.\ne.x.\nlocal function foo()      --  function foo()\n                          --\nend                       --  end\n\n-- Similar too\n\nlocal foo\nfoo = function()          -- foo = function()\n                          --\nend                       -- end\n\n\nNesting Scopes\ndo\n  local x = \"banana\"\n  y = \"apple\"\n\n  do\n    local z = \"tomato\"\n    t = \"pear\"\n    print(x, y, z, t) --&gt; banana  apple  tomato  pear\n  end\n\n  print(x, y, z, t) --&gt; banana  apple  nil  pear\nend\n\nprint(x, y, z, t) --&gt; nil  apple  nil  pear\n\n\nShadowing\nShadowing a variable is when you redefine what the value is later down in the same scope or an inner scope and results in unwanted behavior. A reason why globals should be avoided.\n\ne.x. You have a variable x and you define another one in a different scope y, but you named it x instead.\nlocal x = \"banana\"\n\ndo\n  local x = \"apple\"\n  print(x, y) --&gt; apple (expected banana)  nil (expected apple - shadowed outer variable `x`)\nend\n\nprint(x) --&gt; banana\n\n",
    "author": "Pog Chonk",
    "created": "2021-08-17T00:00:00+00:00"
  },
  {
    "url": "/studio/2021/08/15/task-library.html",
    "title": "Task Library",
    "category": "Studio",
    "excerpt": "Along with the update of the Task Library (see also task library documentation), we got a new set of functions for task scheduling, along with a new and improved wait() function, namely task.wait().\n\n",
    "content": "Along with the update of the Task Library (see also task library documentation), we got a new set of functions for task scheduling, along with a new and improved wait() function, namely task.wait().\n\nThis function is the new equivalent of doing RunService.Heartbeat:Wait() which was always considered a better option.\n\nAlong with the new Find and Replace window Roblox recently introduced it’s now very easy to convert to this new function by use of a regex operation:\n\n  Fill in in the find bar: (?&lt;![\\S\\.])wait\\(\n  Enable regex searching (third icon next to find bar, the dot with the star)\n  Fill in the replace bar: task.wait(\n\n\nWhat this does it looks for all occurences of wait( with a couple of additional checks\n\n  It does not catch cases that are preceded by any other non whitespace character (means it won’t alter things like variables or functions which are trailing with wait(\n  It does not catch cases that are preceded by a dot (this means it won’t accidently overwrite any occurences of existing task.wait(\n\n\nNote: This same method works for all task library functions, for example if you wanted to change the occurences of spawn you would do: (?&lt;![\\S\\.])spawn\\( and task.spawn(.\n",
    "author": "Thodor12",
    "created": "2021-08-15T00:00:00+00:00"
  },
  {
    "url": "/studio/2021/08/13/studio-widgets-not-showing.html",
    "title": "Studio Widgets",
    "category": "Studio",
    "excerpt": "Problems with Studio widgets not showing up?\nIf you ever have an issue with certain widgets not being able to show up you can check the following things:\n\n",
    "content": "Problems with Studio widgets not showing up?\nIf you ever have an issue with certain widgets not being able to show up you can check the following things:\n\n\n  Make sure you actually have the widget enabled. In the menu go to View tab and check if the required widget is enabled.\n  Check if your widget isn’t already open but docked to the same position as another widget, you see tabs showing the individual widgets.\n  Check that your widget is floating around, not docked to studio.\n  Turn on your other monitors, sometimes you might have placed a floating widget on another monitor, in that case the widget will remain in that position despite the monitor being turned off, making it invisible.\n  In case you cannot get the widget to show at all, your last resort is to reset the studio widget layout. You can do this through CTRL + P (Cmd + P on Mac), and then typing in &gt;Reset View, this will reset all the widgets in studio to their default positions.\n\n",
    "author": "Thodor12",
    "created": "2021-08-13T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/06/23/collectionservice.html",
    "title": "CollectionService, how to use it",
    "category": "Scripting",
    "excerpt": "CollectionService is a really underrated service and not many people seem to know about it, on it’s own it honestly doesn’t even look that special but when used correctly this service can improve your game tenfold. Theoretically this service can be used in whatever scenario you desire as it’s versatility is amazing.\n\n",
    "content": "CollectionService is a really underrated service and not many people seem to know about it, on it’s own it honestly doesn’t even look that special but when used correctly this service can improve your game tenfold. Theoretically this service can be used in whatever scenario you desire as it’s versatility is amazing.\n\nWhat does it do?\nCollectionService does nothing more than manage tags. These tags are just basic strings that can be given to any instance in your game. Through CollectionService you can get, add, remove tags, aswell as getting all instances in the game that have a given tag. This allows you to lookup all instances in a game which contain a given tag and quickly get them back as a table in your script, this can be really helpful in scenarios where you don’t want to search through your whole game to find what you’re looking for.\n\nExamples\nI will give 3 short examples of what this can be used for\n\nKill bricks\nAh yes, we all know our classic kill bricks, you step on em, you die. Many people tend to just put a script in the part, bind a Touched listener to the part, and just copy the part along with the script over and over. However now you need to change your script, oops I have to update a hundred scripts, not ideal. CollectionService can help with this by giving all your kill bricks a certain tag, let’s say “KillBrick”, now you only need 1 script which gets all instances in the game with the given tag, iterate all of those parts and give them a Touched listener, 1 script, only 1 place to edit, all killbricks have their implementation.\n\nGetting all characters\nWhat if we want to quickly get all the characters, not just player characters but also NPC’s, again we can use CollectionService to give a tag to all of our humanoids in the game. For players we can do this using CharacterAdded and for our NPC’s we can give them a tag either in studio manually or whenever you create them. This allows you to later on in the code automatically find all humanoids that exist in the game with your tag, meaning you don’t need to even put all NPC’s together in a specific folder and use GetChildren() or something similar, you can just get the entire list in 1 go and be done with it.\n\nDay/Night lighting\nProper lighting is nice in games, even better if your lights adapt to the day night cycle, this is similar to kill bricks, you can give all your lights in your game a tag, whenever the time of day changes you can simply fetch all lights in the game by using CollectionService, iterate all of them and enable or disable all lights in 1 go, only 1 script needed.\n\nLike this you can think of thousands of possible usecases for CollectionService, there’s no end to them.\n\nHow do I start using it?\nSimple, all you have to do is include the service in your scripts using game:GetService(“CollectionService”) like you would do for any other service, you can find it’s documentation here.\n\nNow you might be wondering, how do I actually give these instances tags, well one way is through CollectionService in the command bar like so:\nfor _, item in ipairs(game:GetService(\"Selection\"):Get()) do \n  game:GetService(\"CollectionService\"):AddTag(item, \"YourTagName\")\nend\n\nThis would automatically add the tag with YourTagName to all the instances you have selected in the explorer window.\n\nHowever this is not really ideal, it requires a lot of working, requires you to type out the code in the command bar all the time, etc.\nLuckily the community isn’t stupid and thanks to tiffany352 we have an amazing plugin called the Tag Editor.\nThis plugin allows you to manage all the tags in your game and easily apply them to whatever instance you want.\n",
    "author": "Thodor12",
    "created": "2021-06-23T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/06/11/properties-not-updating.html",
    "title": "Properties not updating",
    "category": "Scripting",
    "excerpt": "Sometimes we see people that do things like setting the Text of a TextLabel recusively, wanting it to constantly update it’s value based on a leaderstats value or something similar, however the GUI doesn’t show a single update despite changing the value of the leaderstats.\n\n",
    "content": "Sometimes we see people that do things like setting the Text of a TextLabel recusively, wanting it to constantly update it’s value based on a leaderstats value or something similar, however the GUI doesn’t show a single update despite changing the value of the leaderstats.\n\nAn example of this is like this:\n\nlocal value = game.Players.LocalPlayer.leaderstats.MyLeaderStat.Value\n\nwhile true do\n  game.Players.LocalPlayer.PlayerGui.MyLeaderstatsGui.TextLabel.Text = value\n  wait()\nend\n\n\nIf you have code like this the text will never update because the variable called value will always contain the same value, the one it got when the script started running.\nLuckily there’s an easy way to solve this. It’s better when you keep the leaderstats value object itself in a variable and instead check the .Value everytime the loop runs, example:\nlocal myLeaderStatsObject = game.Players.LocalPlayer.leaderstats.MyLeaderStat\n\nwhile true do\n  game.Players.LocalPlayer.PlayerGui.MyLeaderstatsGui.TextLabel.Text = myLeaderStatsObject.Value\n  wait()\nend\n\n\nThis will work just fine, however we can improve it one step further, generally it’s not even needed to put things like this in a while loop, it’s just wasted performance, you’re running this code even if there are no updates in the value, this can be solved if we use a Changed listener on the leaderstats values, example:\nlocal myLeaderStatsObject = game.Players.LocalPlayer.leaderstats.MyLeaderStat\n\nmyLeaderStatsObject.Changed:Connect(function(value)\n  game.Players.LocalPlayer.PlayerGui.MyLeaderstatsGui.TextLabel.Text = value\nend)\n\n\nThis code will only run when a change in the value would be detected, greatly increasing the performance of the script.\n\nThis example given the updating of Text is just one example, the exact same idea applies to other cases aswell.\n",
    "author": "Thodor12",
    "created": "2021-06-11T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/05/26/data-saving.html",
    "title": "Data Saving",
    "category": "Scripting",
    "excerpt": "Too often we see people that combine PlayerAdded/PlayerRemoving to make datastore saving scripts.\nIn theory this looks fine but in practice it doesn’t save your data half of the time, why?\n\n",
    "content": "Too often we see people that combine PlayerAdded/PlayerRemoving to make datastore saving scripts.\nIn theory this looks fine but in practice it doesn’t save your data half of the time, why?\n\nWhen does the game exit?\nThe game stops running under any of 3 conditions\n\n  All players have left the game\n  A server shutdown was requested from the game page\n  A game wide server migration was issued (basically server shutdown and teleport)\n\n\nWhen inside of studio you’re always alone, thus if you leave the game, the server will immediately kill itself since the last player left.\n\nAsynchronous\nIt’s important to remember that requests to the datastores are made asychronously, it takes time to complete them, they’re not done just immediately.\nKnowing that the game immediately exits after the last player has left and that a datastore request takes time to complete, it’s obvious that the server shuts down before the datastore request can finish, at this point is when dataloss occurs.\n\nHow to fix it?\nRoblox provides a way that you can run code before the server immediately exits, game:BindToClose, you can bind any amount of functions to right before the game closes, these functions can run for at most 30 seconds before the server kills itself anyway.\nThe way we use this is to save the data for all remaining players to make sure everything is saved before we exit the server.\n\nExample:\nfunction SaveData(player)\n  -- implement your saving logic here\nend\n\ngame.Players.PlayerRemoving:Connect(SaveData)\ngame:BindToClose(function()\n  for _, player in ipairs(game.Players:GetPlayers()) do\n    SaveData(player)\n  end\nend)\n\n\nI get a weird warning in the console saying “Datastore request was added to the queue”.\n\nThis is because you’re making two simultaneous write requests, 1 issued by PlayerRemoving and the other one issued by BindToClose. You can safely ignore this warning because Roblox can only write to the same datastore key every 6 seconds anyway.\n",
    "author": "Thodor12",
    "created": "2021-05-26T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/05/21/characteradded.html",
    "title": "CharacterAdded",
    "category": "Scripting",
    "excerpt": "Often people use\nlocal character = player.Character or player.CharacterAdded:Wait()\n\nin order to fetch the character if it exists or wait until it exists.\nThis call however has some indirect consequences that you do not directly notice.\n\n",
    "content": "Often people use\nlocal character = player.Character or player.CharacterAdded:Wait()\n\nin order to fetch the character if it exists or wait until it exists.\nThis call however has some indirect consequences that you do not directly notice.\n\nUsage in StarterPlayerScripts:\nProblem:\nThe problem with using this statement inside StarterPlayerScripts is that the player scripts run when a player joins and do not run again when characters respawn.\nThis means that you only fetch the character once at the start, and the character variable will then always point to the first character and never updates on respawn.\nThis will cause problems when you then attempt to edit something using that character variable (because that character no longer exists).\n\nSolution:\nAvoid defining the character globally. Make sure that you always fetch the character whenever you need it, this generally means putting it inside of events.\n\nUsage in StarterCharacterScripts:\nProblem:\nIn this case the statement is entirely unnecessary since StarterCharacterScripts run as soon as the character loads in.\n\nSolution:\nUse script.Parent instead\n\nUsage in StarterGui\nProblem:\nCode running in StarterGui is the same as StarterCharacterScripts, the lifetime of a GUI is the same as a character (depending on whether or not ResetOnSpawn is true). This however doesn’t mean you should utilize this solution as scripts here still have the potential to run the same way like StarterPlayerScripts (when ResetOnSpawn is false).\n\nSolution:\nSee usage in StarterPlayerScripts\n\nUsage in PlayerAdded\nProblem:\nWhen used inside PlayerAdded this code will only run for the first time the player spawns in.\n\nSolution:\nUse :Connect for your CharacterAdded event\ngame.Players.PlayerAdded:Connect(function(player)\n  player.CharacterAdded:Connect(function(character)\n\n  end)\nend)\n\n\nUsage inside of event callbacks:\nProblem:\nWhen you use this statement inside of events (for example in remotes) you will cause that thread to hang for some time, this becomes an even greater problem if you game does not have CharacterAutoLoads enabled. Events are meant to be processed as soon as possible and then stop execution.\n\nSolution:\nKnowing that events should always stop execution as soon as possible it’s recommended to abort the event if the condition for an existing character is not met\nlocal character = player.Character\nif not character then return end\n\n\nThis will abort the request as soon as it sees that there is no character, instead of waiting until there is a character present.\n",
    "author": "Thodor12",
    "created": "2021-05-21T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/02/20/pairs-vs-ipairs.html",
    "title": "Pairs vs IPairs",
    "category": "Scripting",
    "excerpt": "pairs internally uses next (in Base Lua, in Luau they use a custom internal iterator).\npairs works on array’s and dictionary’s since it doesn’t have a determined order.\n\n",
    "content": "pairs internally uses next (in Base Lua, in Luau they use a custom internal iterator).\npairs works on array’s and dictionary’s since it doesn’t have a determined order.\n\nipairs numerically indices the table (1, 2, 3, ..., n: where n is the length of the table), which is why it only works on tables with numeric indices (or array’s).\nipairs STOPS on nil values.\n\nThe iterator for pairs looks like.. (in Vanilla Lua, we don’t know about Luau because they haven’t released their internal iterator)\nfunction pairs(t)\n    return next, t, nil --// `nil` is generally avoided since it increases the performance of the loop\nend\n\n\nThe iterator for ipairs looks like..\nfunction iter(a, i)\n    i = i + 1\n    local v = a[i]\n    if v ~= nil then\n        return i, v\n    end\nend\n    \nfunction ipairs(a)\n    return iter, a, 0\nend\n\n\nFun Fact: If you manually set the array-type indices, Lua will think of it as a dictionary instead when iterating with pairs. Still behaves like an array though.\n\nlocal array = {\n  [1] = \"A\",\n  [2] = \"B\"\n}\n\nprint(#array) --&gt; 2\n\nfor index, value in pairs(array) do\n  print(index, value)\nend\n\n--[[\n2 B \n1 A\n\nInstead of\n\n1 A\n2 B\n]]--\n\n",
    "author": "Pog Chonk",
    "created": "2021-02-20T00:00:00+00:00"
  },
  {
    "url": "/scripting/2021/01/28/cframe-constructors.html",
    "title": "CFrame Constructors",
    "category": "Scripting",
    "excerpt": "There’s 2 main constructors for CFrame’s. CFrame.new() and CFrame.lookAt(), these serve similar but different purposes.\nThey both have 2 arguments, except lookAt has 3 arguments.\n\n",
    "content": "There’s 2 main constructors for CFrame’s. CFrame.new() and CFrame.lookAt(), these serve similar but different purposes.\nThey both have 2 arguments, except lookAt has 3 arguments.\n\nFor CFrame.new() , the first argument being the Position (Vector3) of the CFrame. The second one being optional, which is the Position (Vector3) to have it’s LookVector face towards. If the second argument is not set, then default orientation is automatically assigned (0,0,0).\nFor example: CFrame.new(Vector3.new(0,0,0), Vector3.new(0,10,0)) or CFrame.new(Vector3.new(0,0,0)).\nThe difference is that the first one sets the position and where to look at. The second one just sets the position and gives default orientation.\n\nFor CFrame.lookAt(), the first argument being the Position (Vector3) of the CFrame. The second one not being optional, which is the Position (Vector3) to have it’s LookVector look at. The third one is optional though, which is the UpVector (Vector3). By default it’s Vector3.new(0,1,0).\nFor example: CFrame.lookAt(Vector3.new(1,1,1), Vector3.new(1,10,1)) works fine. If you remove the Vector3.new(1,10,1) it’ll warn you that you didn’t define a lookAt position and that you need to assign one.\n\nCFrames have 3 more properties than Vector3s. Those being LookVector, UpVector, and RightVector (labeled below).\n\n-Z -&gt; Forward -&gt; CFrame.new(0,0,-1)\nZ -&gt; Backward -&gt; CFrame.new(0,0,1)\n\nY -&gt; Up -&gt; CFrame.new(0,1,0)\n-Y -&gt; Down -&gt; CFrame.new(0,-1,0)\n\nX -&gt; Right -&gt; CFrame.new(1,0,0)\n-X -&gt; Left -&gt; CFrame.new(-1,0,0)\n\n\nAll of these are some Vector3's in the range [-1,1]\n\nLookVector -&gt; Forward\n-LookVector -&gt; Backward\n\nUpVector -&gt; Up\n-UpVector -&gt; Down\n\nRightVector -&gt; Right\n-RightVector -&gt; Left\n\n",
    "author": "Pog Chonk",
    "created": "2021-01-28T00:00:00+00:00"
  }
  
]